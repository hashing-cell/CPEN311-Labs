Coverage Report by file with details

=================================================================================
=== File: ../vga-core/vga_adapter.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                            1         1         0    100.00

================================Statement Details================================

Statement Coverage for file ../vga-core/vga_adapter.sv --

    1                                                // synopsys translate_off
    2                                                `timescale 1 ps / 1 ps
    3                                                // synopsys translate_on
    4                                                
    5                                                /* VGA Adapter
    6                                                 * ----------------
    7                                                 *
    8                                                 * This is an implementation of a VGA Adapter. The adapter uses VGA mode signalling to initiate
    9                                                 * a 640x480 resolution mode on a computer monitor, with a refresh rate of approximately 60Hz.
    10                                                * It is designed for easy use in an early digital logic design course to facilitate student
    11                                                * projects on the Altera DE2 Educational board.
    12                                                *
    13                                                * This implementation of the VGA adapter can display images of varying colour depth at a resolution of
    14                                                * 320x240 or 160x120 superpixels. The concept of superpixels is introduced to reduce the amount of on-chip
    15                                                * memory used by the adapter. The following table shows the number of bits of on-chip memory used by
    16                                                * the adapter in various resolutions and colour depths.
    17                                                *
    18                                                * -------------------------------------------------------------------------------------------------------------------------------
    19                                                * Resolution | Mono    | 8 colours | 64 colours | 512 colours | 4096 colours | 32768 colours | 262144 colours | 2097152 colours |
    20                                                * -------------------------------------------------------------------------------------------------------------------------------
    21                                                * 160x120    |   19200 |     57600 |     115200 |      172800 |       230400 |        288000 |         345600 |          403200 |
    22                                                * 320x240    |   78600 |    230400 | ############## Does not fit ############################################################## |
    23                                                * -------------------------------------------------------------------------------------------------------------------------------
    24                                                *
    25                                                * By default the adapter works at the resolution of 320x240 with 8 colours. To set the adapter in any of
    26                                                * the other modes, the adapter must be instantiated with specific parameters. These parameters are:
    27                                                * - RESOLUTION - a string that should be either "320x240" or "160x120".
    28                                                * - MONOCHROME - a string that should be "TRUE" if you only want black and white colours, and "FALSE"
    29                                                *                otherwise.
    30                                                * - BITS_PER_COLOUR_CHANNEL  - an integer specifying how many bits are available to describe each colour
    31                                                *                          (R,G,B). A default value of 1 indicates that 1 bit will be used for red
    32                                                *                          channel, 1 for green channel and 1 for blue channel. This allows 8 colours
    33                                                *                          to be used.
    34                                                *
    35                                                * In addition to the above parameters, a BACKGROUND_IMAGE parameter can be specified. The parameter
    36                                                * refers to a memory initilization file (MIF) which contains the initial contents of video memory.
    37                                                * By specifying the initial contents of the memory we can force the adapter to initially display an
    38                                                * image of our choice. Please note that the image described by the BACKGROUND_IMAGE file will only
    39                                                * be valid right after your program the DE2 board. If your circuit draws a single pixel on the screen,
    40                                                * the video memory will be altered and screen contents will be changed. In order to restore the background
    41                                                * image your circuti will have to redraw the background image pixel by pixel, or you will have to
    42                                                * reprogram the DE2 board, thus allowing the video memory to be rewritten.
    43                                                *
    44                                                * To use the module connect the vga_adapter to your circuit. Your circuit should produce a value for
    45                                                * inputs X, Y and plot. When plot is high, at the next positive edge of the input clock the vga_adapter
    46                                                * will change the contents of the video memory for the pixel at location (X,Y). At the next redraw
    47                                                * cycle the VGA controller will update the contants of the screen by reading the video memory and copying
    48                                                * it over to the screen. Since the monitor screen has no memory, the VGA controller has to copy the
    49                                                * contents of the video memory to the screen once every 60th of a second to keep the image stable. Thus,
    50                                                * the video memory should not be used for other purposes as it may interfere with the operation of the
    51                                                * VGA Adapter.
    52                                                *
    53                                                * As a final note, ensure that the following conditions are met when using this module:
    54                                                * 1. You are implementing the the VGA Adapter on the Altera DE2 board. Using another board may change
    55                                                *    the amount of memory you can use, the clock generation mechanism, as well as pin assignments required
    56                                                *    to properly drive the VGA digital-to-analog converter.
    57                                                * 2. Outputs VGA_* should exist in your top level design. They should be assigned pin locations on the
    58                                                *    Altera DE2 board as specified by the DE2_pin_assignments.csv file.
    59                                                * 3. The input clock must have a frequency of 50 MHz with a 50% duty cycle. On the Altera DE2 board
    60                                                *    PIN_N2 is the source for the 50MHz clock.
    61                                                *
    62                                                * During compilation with Quartus II you may receive the following warnings:
    63                                                * - Warning: Variable or input pin "clocken1" is defined but never used
    64                                                * - Warning: Pin "VGA_SYNC" stuck at VCC
    65                                                * - Warning: Found xx output pins without output pin load capacitance assignment
    66                                                * These warnings can be ignored. The first warning is generated, because the software generated
    67                                                * memory module contains an input called "clocken1" and it does not drive logic. The second warning
    68                                                * indicates that the VGA_SYNC signal is always high. This is intentional. The final warning is
    69                                                * generated for the purposes of power analysis. It will persist unless the output pins are assigned
    70                                                * output capacitance. Leaving the capacitance values at 0 pf did not affect the operation of the module.
    71                                                *
    72                                                * If you see any other warnings relating to the vga_adapter, be sure to examine them carefully. They may
    73                                                * cause your circuit to malfunction.
    74                                                *
    75                                                * NOTES/REVISIONS:
    76                                                * July 10, 2007 - Modified the original version of the VGA Adapter written by Sam Vafaee in 2006. The module
    77                                                *		   now supports 2 different resolutions as well as uses half the memory compared to prior
    78                                                *		   implementation. Also, all settings for the module can be specified from the point
    79                                                *		   of instantiation, rather than by modifying the source code. (Tomasz S. Czajkowski)
    80                                                */
    81                                               
    82                                               module vga_adapter(
    83                                               			resetn,
    84                                               			clock,
    85                                               			colour,
    86                                               			x, y, plot,
    87                                               			/* Signals for the DAC to drive the monitor. */
    88                                               			VGA_R,
    89                                               			VGA_G,
    90                                               			VGA_B,
    91                                               			VGA_HS,
    92                                               			VGA_VS,
    93                                               			VGA_BLANK,
    94                                               			VGA_SYNC,
    95                                               			VGA_CLK);
    96                                               
    97                                               	parameter BITS_PER_COLOUR_CHANNEL = 1;
    98                                               	/* The number of bits per colour channel used to represent the colour of each pixel. A value
    99                                               	 * of 1 means that Red, Green and Blue colour channels will use 1 bit each to represent the intensity
    100                                              	 * of the respective colour channel. For BITS_PER_COLOUR_CHANNEL=1, the adapter can display 8 colours.
    101                                              	 * In general, the adapter is able to use 2^(3*BITS_PER_COLOUR_CHANNEL ) colours. The number of colours is
    102                                              	 * limited by the screen resolution and the amount of on-chip memory available on the target device.
    103                                              	 */
    104                                              
    105                                              	parameter MONOCHROME = "FALSE";
    106                                              	/* Set this parameter to "TRUE" if you only wish to use black and white colours. Doing so will reduce
    107                                              	 * the amount of memory you will use by a factor of 3. */
    108                                              
    109                                              	parameter RESOLUTION = "320x240";
    110                                              	/* Set this parameter to "160x120" or "320x240". It will cause the VGA adapter to draw each dot on
    111                                              	 * the screen by using a block of 4x4 pixels ("160x120" resolution) or 2x2 pixels ("320x240" resolution).
    112                                              	 * It effectively reduces the screen resolution to an integer fraction of 640x480. It was necessary
    113                                              	 * to reduce the resolution for the Video Memory to fit within the on-chip memory limits.
    114                                              	 */
    115                                              
    116                                              	parameter BACKGROUND_IMAGE = "background.mif";
    117                                              	/* The initial screen displayed when the circuit is first programmed onto the DE2 board can be
    118                                              	 * defined useing an MIF file. The file contains the initial colour for each pixel on the screen
    119                                              	 * and is placed in the Video Memory (VideoMemory module) upon programming. Note that resetting the
    120                                              	 * VGA Adapter will not cause the Video Memory to revert to the specified image. */
    121                                              
    122                                              	parameter USING_DE1 = "FALSE";
    123                                              	/* If set to "TRUE" it adjust the offset of the drawing mechanism to account for the differences
    124                                              	 * between the DE2 and DE1 VGA digital to analogue converters. Set to "TRUE" if and only if
    125                                              	 * you are running your circuit on a DE1 board. */
    126                                              
    127                                              	/*****************************************************************************/
    128                                              	/* Declare inputs and outputs.                                               */
    129                                              	/*****************************************************************************/
    130                                              	input resetn;
    131                                              	input clock;
    132                                              
    133                                              	/* The colour input can be either 1 bit or 3*BITS_PER_COLOUR_CHANNEL bits wide, depending on
    134                                              	 * the setting of the MONOCHROME parameter.
    135                                              	 */
    136                                              	input [((MONOCHROME == "TRUE") ? (0) : (BITS_PER_COLOUR_CHANNEL*3-1)):0] colour;
    137                                              
    138                                              	/* Specify the number of bits required to represent an (X,Y) coordinate on the screen for
    139                                              	 * a given resolution.
    140                                              	 */
    141                                              	input [((RESOLUTION == "320x240") ? (8) : (7)):0] x;
    142                                              	input [((RESOLUTION == "320x240") ? (7) : (6)):0] y;
    143                                              
    144                                              	/* When plot is high then at the next positive edge of the clock the pixel at (x,y) will change to
    145                                              	 * a new colour, defined by the value of the colour input.
    146                                              	 */
    147                                              	input plot;
    148                                              
    149                                              	/* These outputs drive the VGA display. The VGA_CLK is also used to clock the FSM responsible for
    150                                              	 * controlling the data transferred to the DAC driving the monitor. */
    151                                              	output [9:0] VGA_R;
    152                                              	output [9:0] VGA_G;
    153                                              	output [9:0] VGA_B;
    154                                              	output VGA_HS;
    155                                              	output VGA_VS;
    156                                              	output VGA_BLANK;
    157                                              	output VGA_SYNC;
    158                                              	output VGA_CLK;
    159                                              
    160                                              	/*****************************************************************************/
    161                                              	/* Declare local signals here.                                               */
    162                                              	/*****************************************************************************/
    163                                              
    164                                              	wire valid_160x120;
    165                                              	wire valid_320x240;
    166                                              	/* Set to 1 if the specified coordinates are in a valid range for a given resolution.*/
    167                                              
    168                                              	wire writeEn;
    169                                              	/* This is a local signal that allows the Video Memory contents to be changed.
    170                                              	 * It depends on the screen resolution, the values of X and Y inputs, as well as
    171                                              	 * the state of the plot signal.
    172                                              	 */
    173                                              
    174                                              	wire [((MONOCHROME == "TRUE") ? (0) : (BITS_PER_COLOUR_CHANNEL*3-1)):0] to_ctrl_colour;
    175                                              	/* Pixel colour read by the VGA controller */
    176                                              
    177                                              	wire [((RESOLUTION == "320x240") ? (16) : (14)):0] user_to_video_memory_addr;
    178                                              	/* This bus specifies the address in memory the user must write
    179                                              	 * data to in order for the pixel intended to appear at location (X,Y) to be displayed
    180                                              	 * at the correct location on the screen.
    181                                              	 */
    182                                              
    183                                              	wire [((RESOLUTION == "320x240") ? (16) : (14)):0] controller_to_video_memory_addr;
    184                                              	/* This bus specifies the address in memory the vga controller must read data from
    185                                              	 * in order to determine the colour of a pixel located at coordinate (X,Y) of the screen.
    186                                              	 */
    187                                              
    188                                              	wire clock_25;
    189                                              	/* 25MHz clock generated by dividing the input clock frequency by 2. */
    190                                              
    191                                              	wire vcc, gnd;
    192                                              
    193                                              	/*****************************************************************************/
    194                                              	/* Instances of modules for the VGA adapter.                                 */
    195                                              	/*****************************************************************************/
    196                                              	assign vcc = 1'b1;
    197                                              	assign gnd = 1'b0;
    198                                              
    199                                              	vga_address_translator user_input_translator(
    200                                              					.x(x), .y(y), .mem_address(user_to_video_memory_addr) );
    201                                              		defparam user_input_translator.RESOLUTION = RESOLUTION;
    202                                              	/* Convert user coordinates into a memory address. */
    203                                              
    204             1                      20757     	assign valid_160x120 = (({1'b0, x} >= 0) & ({1'b0, x} < 160) & ({1'b0, y} >= 0) & ({1'b0, y} < 120)) & (RESOLUTION == "160x120");
    205                                              	assign valid_320x240 = (({1'b0, x} >= 0) & ({1'b0, x} < 320) & ({1'b0, y} >= 0) & ({1'b0, y} < 240)) & (RESOLUTION == "320x240");
    206                                              	assign writeEn = (plot) & (valid_160x120 | valid_320x240);
    207                                              	/* Allow the user to plot a pixel if and only if the (X,Y) coordinates supplied are in a valid range. */
    208                                              
    209                                              	/* Create video memory. */
    210                                              	altsyncram	VideoMemory (
    211                                              				.wren_a (writeEn),
    212                                              				.wren_b (gnd),
    213                                              				.clock0 (clock), // write clock
    214                                              				.clock1 (clock_25), // read clock
    215                                              				.clocken0 (vcc), // write enable clock
    216                                              				.clocken1 (vcc), // read enable clock
    217                                              				.address_a (user_to_video_memory_addr),
    218                                              				.address_b (controller_to_video_memory_addr),
    219                                              				.data_a (colour), // data in
    220                                              				.q_b (to_ctrl_colour)	// data out
    221                                              				);
    222                                              	defparam
    223                                              		VideoMemory.width_a = ((MONOCHROME == "FALSE") ? (BITS_PER_COLOUR_CHANNEL*3) : 1),
    224                                              		VideoMemory.width_b = ((MONOCHROME == "FALSE") ? (BITS_PER_COLOUR_CHANNEL*3) : 1),
    225                                              		VideoMemory.intended_device_family = "Cyclone II",
    226                                              		VideoMemory.operation_mode = "DUAL_PORT",
    227                                              		VideoMemory.widthad_a = ((RESOLUTION == "320x240") ? (17) : (15)),
    228                                              		VideoMemory.numwords_a = ((RESOLUTION == "320x240") ? (76800) : (19200)),
    229                                              		VideoMemory.widthad_b = ((RESOLUTION == "320x240") ? (17) : (15)),
    230                                              		VideoMemory.numwords_b = ((RESOLUTION == "320x240") ? (76800) : (19200)),
    231                                              		VideoMemory.outdata_reg_b = "CLOCK1",
    232                                              		VideoMemory.address_reg_b = "CLOCK1",
    233                                              		VideoMemory.clock_enable_input_a = "BYPASS",
    234                                              		VideoMemory.clock_enable_input_b = "BYPASS",
    235                                              		VideoMemory.clock_enable_output_b = "BYPASS",
    236                                              		VideoMemory.power_up_uninitialized = "TRUE";
    237                                              
    238                                              	vga_pll mypll(clock, clock_25);
    239                                              	/* This module generates a clock with half the frequency of the input clock.
    240                                              	 * For the VGA adapter to operate correctly the clock signal 'clock' must be
    241                                              	 * a 50MHz clock. The derived clock, which will then operate at 25MHz, is
    242                                              	 * required to set the monitor into the 640x480@60Hz display mode (also known as
    243                                              	 * the VGA mode).
    244                                              	 */
    245                                              
    246                                              	vga_controller controller(
    247                                              			.vga_clock(clock_25),
    248                                              			.resetn(resetn),
    249                                              			.pixel_colour(to_ctrl_colour),
    250                                              			.memory_address(controller_to_video_memory_addr),
    251                                              			.VGA_R(VGA_R),
    252                                              			.VGA_G(VGA_G),
    253                                              			.VGA_B(VGA_B),
    254                                              			.VGA_HS(VGA_HS),
    255                                              			.VGA_VS(VGA_VS),
    256                                              			.VGA_BLANK(VGA_BLANK),
    257                                              			.VGA_SYNC(VGA_SYNC),
    258                                              			.VGA_CLK(VGA_CLK)
    259                                              		);
    260                                              		defparam controller.BITS_PER_COLOUR_CHANNEL  = BITS_PER_COLOUR_CHANNEL ;
    261                                              		defparam controller.MONOCHROME = MONOCHROME;
    262                                              		defparam controller.RESOLUTION = RESOLUTION;
    263                                              		defparam controller.USING_DE1 = USING_DE1;
    264                                              
    265                                                  // synthesis translate_off
    266             1                      E-hit         always @(posedge clock, negedge resetn) begin
    267                                                      if (resetn === 1'b0) begin
    268                                              `ifdef MODEL_TECH
    269             1                      E-hit                 mti_fli::mti_Command("if { [namespace exists ::de1vga] } { ::de1vga::reset } else { echo \"VGA RESET\" }");
    270                                              `else
    271                                                          $display("VGA RESET");
    272                                              `endif
    273                                                      end else if (plot === 1'b1) begin
    274                                              `ifdef MODEL_TECH
    275             1                      E-hit                 mti_fli::mti_Command($sformatf("if { [namespace exists ::de1vga] } { ::de1vga::plot %0d %0d %0d } else { echo \"VGA PLOT %0d,%0d %0d\" }", x, y, colour, x, y, colour));
    276                                              `else
    277                                                          $display("VGA PLOT %0d,%0d %0d", x, y, colour);
    278                                              `endif
    279                                                      end
    280                                                  end
    281                                                  // synthesis translate_on
    282                                              
    283                                              endmodule

Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                    144        36       108     25.00

================================Toggle Details================================

Toggle Coverage for File ../vga-core/vga_adapter.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
        151                               VGA_R[9]           0           0                                0.00 
        151                               VGA_R[8]           0           0                                0.00 
        151                               VGA_R[7]           0           0                                0.00 
        151                               VGA_R[6]           0           0                                0.00 
        151                               VGA_R[5]           0           0                                0.00 
        151                               VGA_R[4]           0           0                                0.00 
        151                               VGA_R[3]           0           0                                0.00 
        151                               VGA_R[2]           0           0                                0.00 
        151                               VGA_R[1]           0           0                                0.00 
        151                               VGA_R[0]           0           0                                0.00 
        152                               VGA_G[9]           0           0                                0.00 
        152                               VGA_G[8]           0           0                                0.00 
        152                               VGA_G[7]           0           0                                0.00 
        152                               VGA_G[6]           0           0                                0.00 
        152                               VGA_G[5]           0           0                                0.00 
        152                               VGA_G[4]           0           0                                0.00 
        152                               VGA_G[3]           0           0                                0.00 
        152                               VGA_G[2]           0           0                                0.00 
        152                               VGA_G[1]           0           0                                0.00 
        152                               VGA_G[0]           0           0                                0.00 
        153                               VGA_B[9]           0           0                                0.00 
        153                               VGA_B[8]           0           0                                0.00 
        153                               VGA_B[7]           0           0                                0.00 
        153                               VGA_B[6]           0           0                                0.00 
        153                               VGA_B[5]           0           0                                0.00 
        153                               VGA_B[4]           0           0                                0.00 
        153                               VGA_B[3]           0           0                                0.00 
        153                               VGA_B[2]           0           0                                0.00 
        153                               VGA_B[1]           0           0                                0.00 
        153                               VGA_B[0]           0           0                                0.00 
        154                                 VGA_HS           0           0                                0.00 
        155                                 VGA_VS           0           0                                0.00 
        156                              VGA_BLANK           0           0                                0.00 
        158                                VGA_CLK           1           0                               50.00 
        174                      to_ctrl_colour[2]           0           0                                0.00 
        174                      to_ctrl_colour[1]           0           0                                0.00 
        174                      to_ctrl_colour[0]           0           0                                0.00 
        183     controller_to_video_memory_addr[9]           0           0                                0.00 
        183     controller_to_video_memory_addr[8]           0           0                                0.00 
        183     controller_to_video_memory_addr[7]           0           0                                0.00 
        183     controller_to_video_memory_addr[6]           0           0                                0.00 
        183     controller_to_video_memory_addr[5]           0           0                                0.00 
        183     controller_to_video_memory_addr[4]           0           0                                0.00 
        183     controller_to_video_memory_addr[3]           0           0                                0.00 
        183     controller_to_video_memory_addr[2]           0           0                                0.00 
        183     controller_to_video_memory_addr[1]           0           0                                0.00 
        183    controller_to_video_memory_addr[14]           0           0                                0.00 
        183    controller_to_video_memory_addr[13]           0           0                                0.00 
        183    controller_to_video_memory_addr[12]           0           0                                0.00 
        183    controller_to_video_memory_addr[11]           0           0                                0.00 
        183    controller_to_video_memory_addr[10]           0           0                                0.00 
        183     controller_to_video_memory_addr[0]           0           0                                0.00 
        188                               clock_25           1           0                               50.00 
        191                                    vcc           0           0                                0.00 
        191                                    gnd           0           0                                0.00 

Total Node Count     =         72 
Toggled Node Count   =         17 
Untoggled Node Count =         55 

Toggle Coverage      =      25.00% (36 of 144 bins)

=================================================================================
=== File: ../vga-core/vga_address_translator.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                            4         4         0    100.00

================================Statement Details================================

Statement Coverage for file ../vga-core/vga_address_translator.sv --

    1                                                // synopsys translate_off
    2                                                `timescale 1 ps / 1 ps
    3                                                // synopsys translate_on
    4                                                
    5                                                /* This module converts a user specified coordinates into a memory address.
    6                                                 * The output of the module depends on the resolution set by the user.
    7                                                 */
    8                                                module vga_address_translator(x, y, mem_address);
    9                                                
    10                                               	parameter RESOLUTION = "320x240";
    11                                               	/* Set this parameter to "160x120" or "320x240". It will cause the VGA adapter to draw each dot on
    12                                               	 * the screen by using a block of 4x4 pixels ("160x120" resolution) or 2x2 pixels ("320x240" resolution).
    13                                               	 * It effectively reduces the screen resolution to an integer fraction of 640x480. It was necessary
    14                                               	 * to reduce the resolution for the Video Memory to fit within the on-chip memory limits.
    15                                               	 */
    16                                               
    17                                               	input [((RESOLUTION == "320x240") ? (8) : (7)):0] x;
    18                                               	input [((RESOLUTION == "320x240") ? (7) : (6)):0] y;
    19                                               	output reg [((RESOLUTION == "320x240") ? (16) : (14)):0] mem_address;
    20                                               
    21                                               	/* The basic formula is address = y*WIDTH + x;
    22                                               	 * For 320x240 resolution we can write 320 as (256 + 64). Memory address becomes
    23                                               	 * (y*256) + (y*64) + x;
    24                                               	 * This simplifies multiplication a simple shift and add operation.
    25                                               	 * A leading 0 bit is added to each operand to ensure that they are treated as unsigned
    26                                               	 * inputs. By default the use a '+' operator will generate a signed adder.
    27                                               	 * Similarly, for 160x120 resolution we write 160 as 128+32.
    28                                               	 */
    29              1                      20759     	wire [16:0] res_320x240 = ({1'b0, y, 8'd0} + {1'b0, y, 6'd0} + {1'b0, x});
    30              1                      20759     	wire [15:0] res_160x120 = ({1'b0, y, 7'd0} + {1'b0, y, 5'd0} + {1'b0, x});
    31                                               
    32              1                      20757     	always @(*)
    33                                               	begin
    34                                               		if (RESOLUTION == "320x240")
    35                                               			mem_address = res_320x240;
    36                                               		else
    37              1                      20757     			mem_address = res_160x120[14:0];
    38                                               	end
    39                                               endmodule

Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                     96        92         4     95.83

================================Toggle Details================================

Toggle Coverage for File ../vga-core/vga_address_translator.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
         29                        res_320x240[16]           0           0                                0.00 
         30                        res_160x120[15]           0           0                                0.00 

Total Node Count     =         48 
Toggled Node Count   =         46 
Untoggled Node Count =          2 

Toggle Coverage      =      95.83% (92 of 96 bins)

=================================================================================
=== File: ../vga-core/vga_controller.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           32        29         3     90.62

================================Statement Details================================

Statement Coverage for file ../vga-core/vga_controller.sv --

    1                                                // synopsys translate_off
    2                                                `timescale 1 ps / 1 ps
    3                                                // synopsys translate_on
    4                                                
    5                                                /* This module implements the VGA controller. It assumes a 25MHz clock is supplied as input.
    6                                                 *
    7                                                 * General approach:
    8                                                 * Go through each line of the screen and read the colour each pixel on that line should have from
    9                                                 * the Video memory. To do that for each (x,y) pixel on the screen convert (x,y) coordinate to
    10                                                * a memory_address at which the pixel colour is stored in Video memory. Once the pixel colour is
    11                                                * read from video memory its brightness is first increased before it is forwarded to the VGA DAC.
    12                                                */
    13                                               module vga_controller(	vga_clock, resetn, pixel_colour, memory_address,
    14                                               		VGA_R, VGA_G, VGA_B,
    15                                               		VGA_HS, VGA_VS, VGA_BLANK,
    16                                               		VGA_SYNC, VGA_CLK);
    17                                               
    18                                               	/* Screen resolution and colour depth parameters. */
    19                                               
    20                                               	parameter BITS_PER_COLOUR_CHANNEL = 1;
    21                                               	/* The number of bits per colour channel used to represent the colour of each pixel. A value
    22                                               	 * of 1 means that Red, Green and Blue colour channels will use 1 bit each to represent the intensity
    23                                               	 * of the respective colour channel. For BITS_PER_COLOUR_CHANNEL=1, the adapter can display 8 colours.
    24                                               	 * In general, the adapter is able to use 2^(3*BITS_PER_COLOUR_CHANNEL) colours. The number of colours is
    25                                               	 * limited by the screen resolution and the amount of on-chip memory available on the target device.
    26                                               	 */
    27                                               
    28                                               	parameter MONOCHROME = "FALSE";
    29                                               	/* Set this parameter to "TRUE" if you only wish to use black and white colours. Doing so will reduce
    30                                               	 * the amount of memory you will use by a factor of 3. */
    31                                               
    32                                               	parameter RESOLUTION = "320x240";
    33                                               	/* Set this parameter to "160x120" or "320x240". It will cause the VGA adapter to draw each dot on
    34                                               	 * the screen by using a block of 4x4 pixels ("160x120" resolution) or 2x2 pixels ("320x240" resolution).
    35                                               	 * It effectively reduces the screen resolution to an integer fraction of 640x480. It was necessary
    36                                               	 * to reduce the resolution for the Video Memory to fit within the on-chip memory limits.
    37                                               	 */
    38                                               
    39                                               	parameter USING_DE1 = "FALSE";
    40                                               	/* If set to "TRUE" it adjust the offset of the drawing mechanism to account for the differences
    41                                               	 * between the DE2 and DE1 VGA digital to analogue converters. Set to "TRUE" if and only if
    42                                               	 * you are running your circuit on a DE1 board. */
    43                                               
    44                                               	//--- Timing parameters.
    45                                               	/* Recall that the VGA specification requires a few more rows and columns are drawn
    46                                               	 * when refreshing the screen than are actually present on the screen. This is necessary to
    47                                               	 * generate the vertical and the horizontal syncronization signals. If you wish to use a
    48                                               	 * display mode other than 640x480 you will need to modify the parameters below as well
    49                                               	 * as change the frequency of the clock driving the monitor (VGA_CLK).
    50                                               	 */
    51                                               	parameter C_VERT_NUM_PIXELS  = 11'd480;
    52                                               	parameter C_VERT_SYNC_START  = 11'd493;
    53                                               	parameter C_VERT_SYNC_END    = 11'd494; //(C_VERT_SYNC_START + 2 - 1);
    54                                               	parameter C_VERT_TOTAL_COUNT = 11'd525;
    55                                               
    56                                               	parameter C_HORZ_NUM_PIXELS  = 11'd640;
    57                                               	parameter C_HORZ_SYNC_START  = 11'd659;
    58                                               	parameter C_HORZ_SYNC_END    = 11'd754; //(C_HORZ_SYNC_START + 96 - 1);
    59                                               	parameter C_HORZ_TOTAL_COUNT = 11'd800;
    60                                               
    61                                               	/*****************************************************************************/
    62                                               	/* Declare inputs and outputs.                                               */
    63                                               	/*****************************************************************************/
    64                                               
    65                                               	input vga_clock, resetn;
    66                                               	input [((MONOCHROME == "TRUE") ? (0) : (BITS_PER_COLOUR_CHANNEL*3-1)):0] pixel_colour;
    67                                               	output [((RESOLUTION == "320x240") ? (16) : (14)):0] memory_address;
    68                                               	output reg [9:0] VGA_R;
    69                                               	output reg [9:0] VGA_G;
    70                                               	output reg [9:0] VGA_B;
    71                                               	output reg VGA_HS;
    72                                               	output reg VGA_VS;
    73                                               	output reg VGA_BLANK;
    74                                               	output VGA_SYNC, VGA_CLK;
    75                                               
    76                                               	/*****************************************************************************/
    77                                               	/* Local Signals.                                                            */
    78                                               	/*****************************************************************************/
    79                                               
    80                                               	reg VGA_HS1;
    81                                               	reg VGA_VS1;
    82                                               	reg VGA_BLANK1;
    83                                               	reg [9:0] xCounter, yCounter;
    84                                               	wire xCounter_clear;
    85                                               	wire yCounter_clear;
    86                                               	wire vcc;
    87                                               
    88                                               	reg [((RESOLUTION == "320x240") ? (8) : (7)):0] x;
    89                                               	reg [((RESOLUTION == "320x240") ? (7) : (6)):0] y;
    90                                               	/* Inputs to the converter. */
    91                                               
    92                                               	/*****************************************************************************/
    93                                               	/* Controller implementation.                                                */
    94                                               	/*****************************************************************************/
    95                                               
    96                                               	assign vcc =1'b1;
    97                                               
    98                                               	/* A counter to scan through a horizontal line. */
    99              1                          2     	always @(posedge vga_clock or negedge resetn)
    100                                              	begin
    101                                              		if (!resetn)
    102             1                          1     			xCounter <= 10'd0;
    103                                              		else if (xCounter_clear)
    104             1                    ***0***     			xCounter <= 10'd0;
    105                                              		else
    106                                              		begin
    107             1                          1     			xCounter <= xCounter + 1'b1;
    108                                              		end
    109                                              	end
    110             1                          3     	assign xCounter_clear = (xCounter == (C_HORZ_TOTAL_COUNT-1));
    111                                              
    112                                              	/* A counter to scan vertically, indicating the row currently being drawn. */
    113             1                          2     	always @(posedge vga_clock or negedge resetn)
    114                                              	begin
    115                                              		if (!resetn)
    116             1                          1     			yCounter <= 10'd0;
    117                                              		else if (xCounter_clear && yCounter_clear)
    118             1                    ***0***     			yCounter <= 10'd0;
    119                                              		else if (xCounter_clear)		//Increment when x counter resets
    120             1                    ***0***     			yCounter <= yCounter + 1'b1;
    121                                              	end
    122             1                          2     	assign yCounter_clear = (yCounter == (C_VERT_TOTAL_COUNT-1));
    123                                              
    124                                              	/* Convert the xCounter/yCounter location from screen pixels (640x480) to our
    125                                              	 * local dots (320x240 or 160x120). Here we effectively divide x/y coordinate by 2 or 4,
    126                                              	 * depending on the resolution. */
    127             1                          1     	always @(*)
    128                                              	begin
    129                                              		if (RESOLUTION == "320x240")
    130                                              		begin
    131                                              			x = xCounter[9:1];
    132                                              			y = yCounter[8:1];
    133                                              		end
    134                                              		else
    135                                              		begin
    136             1                          1     			x = xCounter[9:2];
    137             1                          1     			y = yCounter[8:2];
    138                                              		end
    139                                              	end
    140                                              
    141                                              	/* Change the (x,y) coordinate into a memory address. */
    142                                              	vga_address_translator controller_translator(
    143                                              					.x(x), .y(y), .mem_address(memory_address) );
    144                                              		defparam controller_translator.RESOLUTION = RESOLUTION;
    145                                              
    146                                              
    147                                              	/* Generate the vertical and horizontal synchronization pulses. */
    148             1                          1     	always @(posedge vga_clock)
    149                                              	begin
    150                                              		//- Sync Generator (ACTIVE LOW)
    151                                              		if (USING_DE1 == "TRUE")
    152                                              			VGA_HS1 <= ~((xCounter >= C_HORZ_SYNC_START-2) && (xCounter <= C_HORZ_SYNC_END-2));
    153                                              		else
    154             1                          1     			VGA_HS1 <= ~((xCounter >= C_HORZ_SYNC_START) && (xCounter <= C_HORZ_SYNC_END));
    155             1                          1     		VGA_VS1 <= ~((yCounter >= C_VERT_SYNC_START) && (yCounter <= C_VERT_SYNC_END));
    156                                              
    157                                              		//- Current X and Y is valid pixel range
    158             1                          1     		VGA_BLANK1 <= ((xCounter < C_HORZ_NUM_PIXELS) && (yCounter < C_VERT_NUM_PIXELS));
    159                                              
    160                                              		//- Add 1 cycle delay
    161             1                          1     		VGA_HS <= VGA_HS1;
    162             1                          1     		VGA_VS <= VGA_VS1;
    163             1                          1     		VGA_BLANK <= VGA_BLANK1;
    164                                              	end
    165                                              
    166                                              	/* VGA sync should be 1 at all times. */
    167                                              	assign VGA_SYNC = vcc;
    168                                              
    169                                              	/* Generate the VGA clock signal. */
    170                                              	assign VGA_CLK = vga_clock;
    171                                              
    172                                              	/* Brighten the colour output. */
    173                                              	// The colour input is first processed to brighten the image a little. Setting the top
    174                                              	// bits to correspond to the R,G,B colour makes the image a bit dull. To brighten the image,
    175                                              	// each bit of the colour is replicated through the 10 DAC colour input bits. For example,
    176                                              	// when BITS_PER_COLOUR_CHANNEL is 2 and the red component is set to 2'b10, then the
    177                                              	// VGA_R input to the DAC will be set to 10'b1010101010.
    178                                              
    179                                              	integer index;
    180                                              	integer sub_index;
    181                                              
    182                                              	wire on_screen;
    183                                              
    184             1                          3     	assign on_screen = (USING_DE1 == "TRUE") ?
    185                                              							(({1'b0, xCounter} >= 2) & ({1'b0, xCounter} < C_HORZ_NUM_PIXELS+2) & ({1'b0, yCounter} < C_VERT_NUM_PIXELS)) :
    186                                              							(({1'b0, xCounter} >= 0) & ({1'b0, xCounter} < C_HORZ_NUM_PIXELS+2) & ({1'b0, yCounter} < C_VERT_NUM_PIXELS));
    187                                              
    188             1                          2     	always @(pixel_colour or on_screen)
    189                                              	begin
    190             1                          2     		VGA_R <= 'b0;
    191             1                          2     		VGA_G <= 'b0;
    192             1                          2     		VGA_B <= 'b0;
    193                                              		if (MONOCHROME == "FALSE")
    194                                              		begin
    195             1                          2     			for (index = 10-BITS_PER_COLOUR_CHANNEL; index >= 0; index = index - BITS_PER_COLOUR_CHANNEL)
    195             2                         20     
    196                                              			begin
    197             1                         20     				for (sub_index = BITS_PER_COLOUR_CHANNEL - 1; sub_index >= 0; sub_index = sub_index - 1)
    197             2                         20     
    198                                              				begin
    199             1                         20     					VGA_R[sub_index+index] <= on_screen & pixel_colour[sub_index + BITS_PER_COLOUR_CHANNEL*2];
    200             1                         20     					VGA_G[sub_index+index] <= on_screen & pixel_colour[sub_index + BITS_PER_COLOUR_CHANNEL];
    201             1                         20     					VGA_B[sub_index+index] <= on_screen & pixel_colour[sub_index];
    202                                              				end
    203                                              			end
    204                                              		end
    205                                              		else
    206                                              		begin
    207                                              			for (index = 0; index < 10; index = index + 1)
    208                                              			begin
    209                                              				VGA_R[index] <= on_screen & pixel_colour[0:0];
    210                                              				VGA_G[index] <= on_screen & pixel_colour[0:0];
    211                                              				VGA_B[index] <= on_screen & pixel_colour[0:0];
    212                                              			end
    213                                              		end
    214                                              	end
    215                                              
    216                                              endmodule

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         7         4         3     57.14

================================Branch Details================================

Branch Coverage for file ../vga-core/vga_controller.sv --

------------------------------------IF Branch------------------------------------
    101                                        2     Count coming in to IF
    101             1                          1     		if (!resetn)
    103             1                    ***0***     		else if (xCounter_clear)
    105             1                          1     		else
Branch totals: 2 hits of 3 branches = 66.66%

------------------------------------IF Branch------------------------------------
    115                                        2     Count coming in to IF
    115             1                          1     		if (!resetn)
    117             1                    ***0***     		else if (xCounter_clear && yCounter_clear)
    119             1                    ***0***     		else if (xCounter_clear)		//Increment when x counter resets
                                               1     All False Count
Branch totals: 2 hits of 4 branches = 50.00%


Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                    276         1       275      0.36

================================Toggle Details================================

Toggle Coverage for File ../vga-core/vga_controller.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
         68                               VGA_R[9]           0           0                                0.00 
         68                               VGA_R[8]           0           0                                0.00 
         68                               VGA_R[7]           0           0                                0.00 
         68                               VGA_R[6]           0           0                                0.00 
         68                               VGA_R[5]           0           0                                0.00 
         68                               VGA_R[4]           0           0                                0.00 
         68                               VGA_R[3]           0           0                                0.00 
         68                               VGA_R[2]           0           0                                0.00 
         68                               VGA_R[1]           0           0                                0.00 
         68                               VGA_R[0]           0           0                                0.00 
         69                               VGA_G[9]           0           0                                0.00 
         69                               VGA_G[8]           0           0                                0.00 
         69                               VGA_G[7]           0           0                                0.00 
         69                               VGA_G[6]           0           0                                0.00 
         69                               VGA_G[5]           0           0                                0.00 
         69                               VGA_G[4]           0           0                                0.00 
         69                               VGA_G[3]           0           0                                0.00 
         69                               VGA_G[2]           0           0                                0.00 
         69                               VGA_G[1]           0           0                                0.00 
         69                               VGA_G[0]           0           0                                0.00 
         70                               VGA_B[9]           0           0                                0.00 
         70                               VGA_B[8]           0           0                                0.00 
         70                               VGA_B[7]           0           0                                0.00 
         70                               VGA_B[6]           0           0                                0.00 
         70                               VGA_B[5]           0           0                                0.00 
         70                               VGA_B[4]           0           0                                0.00 
         70                               VGA_B[3]           0           0                                0.00 
         70                               VGA_B[2]           0           0                                0.00 
         70                               VGA_B[1]           0           0                                0.00 
         70                               VGA_B[0]           0           0                                0.00 
         71                                 VGA_HS           0           0                                0.00 
         72                                 VGA_VS           0           0                                0.00 
         73                              VGA_BLANK           0           0                                0.00 
         80                                VGA_HS1           0           0                                0.00 
         81                                VGA_VS1           0           0                                0.00 
         82                             VGA_BLANK1           0           0                                0.00 
         83                            yCounter[9]           0           0                                0.00 
         83                            yCounter[8]           0           0                                0.00 
         83                            yCounter[7]           0           0                                0.00 
         83                            yCounter[6]           0           0                                0.00 
         83                            yCounter[5]           0           0                                0.00 
         83                            yCounter[4]           0           0                                0.00 
         83                            yCounter[3]           0           0                                0.00 
         83                            yCounter[2]           0           0                                0.00 
         83                            yCounter[1]           0           0                                0.00 
         83                            yCounter[0]           0           0                                0.00 
         83                            xCounter[9]           0           0                                0.00 
         83                            xCounter[8]           0           0                                0.00 
         83                            xCounter[7]           0           0                                0.00 
         83                            xCounter[6]           0           0                                0.00 
         83                            xCounter[5]           0           0                                0.00 
         83                            xCounter[4]           0           0                                0.00 
         83                            xCounter[3]           0           0                                0.00 
         83                            xCounter[2]           0           0                                0.00 
         83                            xCounter[1]           0           0                                0.00 
         83                            xCounter[0]           0           1                               50.00 
         84                         xCounter_clear           0           0                                0.00 
         85                         yCounter_clear           0           0                                0.00 
         88                                   x[7]           0           0                                0.00 
         88                                   x[6]           0           0                                0.00 
         88                                   x[5]           0           0                                0.00 
         88                                   x[4]           0           0                                0.00 
         88                                   x[3]           0           0                                0.00 
         88                                   x[2]           0           0                                0.00 
         88                                   x[1]           0           0                                0.00 
         88                                   x[0]           0           0                                0.00 
         89                                   y[6]           0           0                                0.00 
         89                                   y[5]           0           0                                0.00 
         89                                   y[4]           0           0                                0.00 
         89                                   y[3]           0           0                                0.00 
         89                                   y[2]           0           0                                0.00 
         89                                   y[1]           0           0                                0.00 
         89                                   y[0]           0           0                                0.00 
        179                               index[9]           0           0                                0.00 
        179                               index[8]           0           0                                0.00 
        179                               index[7]           0           0                                0.00 
        179                               index[6]           0           0                                0.00 
        179                               index[5]           0           0                                0.00 
        179                               index[4]           0           0                                0.00 
        179                               index[3]           0           0                                0.00 
        179                              index[31]           0           0                                0.00 
        179                              index[30]           0           0                                0.00 
        179                               index[2]           0           0                                0.00 
        179                              index[29]           0           0                                0.00 
        179                              index[28]           0           0                                0.00 
        179                              index[27]           0           0                                0.00 
        179                              index[26]           0           0                                0.00 
        179                              index[25]           0           0                                0.00 
        179                              index[24]           0           0                                0.00 
        179                              index[23]           0           0                                0.00 
        179                              index[22]           0           0                                0.00 
        179                              index[21]           0           0                                0.00 
        179                              index[20]           0           0                                0.00 
        179                               index[1]           0           0                                0.00 
        179                              index[19]           0           0                                0.00 
        179                              index[18]           0           0                                0.00 
        179                              index[17]           0           0                                0.00 
        179                              index[16]           0           0                                0.00 
        179                              index[15]           0           0                                0.00 
        179                              index[14]           0           0                                0.00 
        179                              index[13]           0           0                                0.00 
        179                              index[12]           0           0                                0.00 
        179                              index[11]           0           0                                0.00 
        179                              index[10]           0           0                                0.00 
        179                               index[0]           0           0                                0.00 
        180                           sub_index[9]           0           0                                0.00 
        180                           sub_index[8]           0           0                                0.00 
        180                           sub_index[7]           0           0                                0.00 
        180                           sub_index[6]           0           0                                0.00 
        180                           sub_index[5]           0           0                                0.00 
        180                           sub_index[4]           0           0                                0.00 
        180                           sub_index[3]           0           0                                0.00 
        180                          sub_index[31]           0           0                                0.00 
        180                          sub_index[30]           0           0                                0.00 
        180                           sub_index[2]           0           0                                0.00 
        180                          sub_index[29]           0           0                                0.00 
        180                          sub_index[28]           0           0                                0.00 
        180                          sub_index[27]           0           0                                0.00 
        180                          sub_index[26]           0           0                                0.00 
        180                          sub_index[25]           0           0                                0.00 
        180                          sub_index[24]           0           0                                0.00 
        180                          sub_index[23]           0           0                                0.00 
        180                          sub_index[22]           0           0                                0.00 
        180                          sub_index[21]           0           0                                0.00 
        180                          sub_index[20]           0           0                                0.00 
        180                           sub_index[1]           0           0                                0.00 
        180                          sub_index[19]           0           0                                0.00 
        180                          sub_index[18]           0           0                                0.00 
        180                          sub_index[17]           0           0                                0.00 
        180                          sub_index[16]           0           0                                0.00 
        180                          sub_index[15]           0           0                                0.00 
        180                          sub_index[14]           0           0                                0.00 
        180                          sub_index[13]           0           0                                0.00 
        180                          sub_index[12]           0           0                                0.00 
        180                          sub_index[11]           0           0                                0.00 
        180                          sub_index[10]           0           0                                0.00 
        180                           sub_index[0]           0           0                                0.00 
        182                              on_screen           0           0                                0.00 

Total Node Count     =        138 
Toggled Node Count   =          0 
Untoggled Node Count =        138 

Toggle Coverage      =       0.36% (1 of 276 bins)

=================================================================================
=== File: ../vga-core/vga_pll.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                            1         1         0    100.00

================================Statement Details================================

Statement Coverage for file ../vga-core/vga_pll.sv --

    1                                                // megafunction wizard: %ALTPLL%
    2                                                // GENERATION: STANDARD
    3                                                // VERSION: WM1.0
    4                                                // MODULE: altpll
    5                                                
    6                                                // ============================================================
    7                                                // File Name: VgaPll.v
    8                                                // Megafunction Name(s):
    9                                                // 			altpll
    10                                               // ============================================================
    11                                               // ************************************************************
    12                                               // THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
    13                                               //
    14                                               // 5.0 Build 168 06/22/2005 SP 1 SJ Full Version
    15                                               // ************************************************************
    16                                               
    17                                               
    18                                               //Copyright (C) 1991-2005 Altera Corporation
    19                                               //Your use of Altera Corporation's design tools, logic functions
    20                                               //and other software and tools, and its AMPP partner logic
    21                                               //functions, and any output files any of the foregoing
    22                                               //(including device programming or simulation files), and any
    23                                               //associated documentation or information are expressly subject
    24                                               //to the terms and conditions of the Altera Program License
    25                                               //Subscription Agreement, Altera MegaCore Function License
    26                                               //Agreement, or other applicable license agreement, including,
    27                                               //without limitation, that your use is for the sole purpose of
    28                                               //programming logic devices manufactured by Altera and sold by
    29                                               //Altera or its authorized distributors.  Please refer to the
    30                                               //applicable agreement for further details.
    31                                               
    32                                               
    33                                               // synopsys translate_off
    34                                               `timescale 1 ps / 1 ps
    35                                               // synopsys translate_on
    36                                               module vga_pll (
    37                                               	clock_in,
    38                                               	clock_out);
    39                                               
    40                                               	input	  clock_in;
    41                                               	output	  clock_out;
    42                                               
    43                                               	wire [5:0] clock_output_bus;
    44                                               	wire [1:0] clock_input_bus;
    45                                               	wire gnd;
    46                                               
    47                                               	assign gnd = 1'b0;
    48              1                      42265     	assign clock_input_bus = { gnd, clock_in };
    49                                               
    50                                               	altpll	altpll_component (
    51                                               				.inclk (clock_input_bus),
    52                                               				.clk (clock_output_bus)
    53                                               				);
    54                                               	defparam
    55                                               		altpll_component.operation_mode = "NORMAL",
    56                                               		altpll_component.intended_device_family = "Cyclone II",
    57                                               		altpll_component.lpm_type = "altpll",
    58                                               		altpll_component.pll_type = "FAST",
    59                                               		/* Specify the input clock to be a 50MHz clock. A 50 MHz clock is present
    60                                               		 * on PIN_N2 on the DE2 board. We need to specify the input clock frequency
    61                                               		 * in order to set up the PLL correctly. To do this we must put the input clock
    62                                               		 * period measured in picoseconds in the inclk0_input_frequency parameter.
    63                                               		 * 1/(20000 ps) = 0.5 * 10^(5) Hz = 50 * 10^(6) Hz = 50 MHz. */
    64                                               		altpll_component.inclk0_input_frequency = 20000,
    65                                               		altpll_component.primary_clock = "INCLK0",
    66                                               		/* Specify output clock parameters. The output clock should have a
    67                                               		 * frequency of 25 MHz, with 50% duty cycle. */
    68                                               		altpll_component.compensate_clock = "CLK0",
    69                                               		altpll_component.clk0_phase_shift = "0",
    70                                               		altpll_component.clk0_divide_by = 2,
    71                                               		altpll_component.clk0_multiply_by = 1,
    72                                               		altpll_component.clk0_duty_cycle = 50;
    73                                               
    74                                               	assign clock_out = clock_output_bus[0];
    75                                               
    76                                               endmodule
    77                                               
    78                                               // ============================================================
    79                                               // CNX file retrieval info
    80                                               // ============================================================
    81                                               // Retrieval info: PRIVATE: MIRROR_CLK0 STRING "0"
    82                                               // Retrieval info: PRIVATE: PHASE_SHIFT_UNIT0 STRING "deg"
    83                                               // Retrieval info: PRIVATE: OUTPUT_FREQ_UNIT0 STRING "MHz"
    84                                               // Retrieval info: PRIVATE: INCLK1_FREQ_UNIT_COMBO STRING "MHz"
    85                                               // Retrieval info: PRIVATE: SPREAD_USE STRING "0"
    86                                               // Retrieval info: PRIVATE: SPREAD_FEATURE_ENABLED STRING "0"
    87                                               // Retrieval info: PRIVATE: GLOCKED_COUNTER_EDIT_CHANGED STRING "1"
    88                                               // Retrieval info: PRIVATE: GLOCK_COUNTER_EDIT NUMERIC "1048575"
    89                                               // Retrieval info: PRIVATE: SRC_SYNCH_COMP_RADIO STRING "0"
    90                                               // Retrieval info: PRIVATE: DUTY_CYCLE0 STRING "50.00000000"
    91                                               // Retrieval info: PRIVATE: PHASE_SHIFT0 STRING "0.00000000"
    92                                               // Retrieval info: PRIVATE: MULT_FACTOR0 NUMERIC "1"
    93                                               // Retrieval info: PRIVATE: OUTPUT_FREQ_MODE0 STRING "1"
    94                                               // Retrieval info: PRIVATE: SPREAD_PERCENT STRING "0.500"
    95                                               // Retrieval info: PRIVATE: LOCKED_OUTPUT_CHECK STRING "0"
    96                                               // Retrieval info: PRIVATE: PLL_ARESET_CHECK STRING "0"
    97                                               // Retrieval info: PRIVATE: STICKY_CLK0 STRING "1"
    98                                               // Retrieval info: PRIVATE: BANDWIDTH STRING "1.000"
    99                                               // Retrieval info: PRIVATE: BANDWIDTH_USE_CUSTOM STRING "0"
    100                                              // Retrieval info: PRIVATE: DEVICE_SPEED_GRADE STRING "Any"
    101                                              // Retrieval info: PRIVATE: SPREAD_FREQ STRING "50.000"
    102                                              // Retrieval info: PRIVATE: BANDWIDTH_FEATURE_ENABLED STRING "0"
    103                                              // Retrieval info: PRIVATE: LONG_SCAN_RADIO STRING "1"
    104                                              // Retrieval info: PRIVATE: PLL_ENHPLL_CHECK NUMERIC "0"
    105                                              // Retrieval info: PRIVATE: LVDS_MODE_DATA_RATE_DIRTY NUMERIC "0"
    106                                              // Retrieval info: PRIVATE: USE_CLK0 STRING "1"
    107                                              // Retrieval info: PRIVATE: INCLK1_FREQ_EDIT_CHANGED STRING "1"
    108                                              // Retrieval info: PRIVATE: SCAN_FEATURE_ENABLED STRING "0"
    109                                              // Retrieval info: PRIVATE: ZERO_DELAY_RADIO STRING "0"
    110                                              // Retrieval info: PRIVATE: PLL_PFDENA_CHECK STRING "0"
    111                                              // Retrieval info: PRIVATE: CREATE_CLKBAD_CHECK STRING "0"
    112                                              // Retrieval info: PRIVATE: INCLK1_FREQ_EDIT STRING "50.000"
    113                                              // Retrieval info: PRIVATE: CUR_DEDICATED_CLK STRING "c0"
    114                                              // Retrieval info: PRIVATE: PLL_FASTPLL_CHECK NUMERIC "0"
    115                                              // Retrieval info: PRIVATE: ACTIVECLK_CHECK STRING "0"
    116                                              // Retrieval info: PRIVATE: BANDWIDTH_FREQ_UNIT STRING "MHz"
    117                                              // Retrieval info: PRIVATE: INCLK0_FREQ_UNIT_COMBO STRING "MHz"
    118                                              // Retrieval info: PRIVATE: GLOCKED_MODE_CHECK STRING "0"
    119                                              // Retrieval info: PRIVATE: NORMAL_MODE_RADIO STRING "1"
    120                                              // Retrieval info: PRIVATE: CUR_FBIN_CLK STRING "e0"
    121                                              // Retrieval info: PRIVATE: DIV_FACTOR0 NUMERIC "1"
    122                                              // Retrieval info: PRIVATE: INCLK1_FREQ_UNIT_CHANGED STRING "1"
    123                                              // Retrieval info: PRIVATE: HAS_MANUAL_SWITCHOVER STRING "1"
    124                                              // Retrieval info: PRIVATE: EXT_FEEDBACK_RADIO STRING "0"
    125                                              // Retrieval info: PRIVATE: PLL_AUTOPLL_CHECK NUMERIC "1"
    126                                              // Retrieval info: PRIVATE: CLKLOSS_CHECK STRING "0"
    127                                              // Retrieval info: PRIVATE: BANDWIDTH_USE_AUTO STRING "1"
    128                                              // Retrieval info: PRIVATE: SHORT_SCAN_RADIO STRING "0"
    129                                              // Retrieval info: PRIVATE: LVDS_MODE_DATA_RATE STRING "Not Available"
    130                                              // Retrieval info: PRIVATE: CLKSWITCH_CHECK STRING "1"
    131                                              // Retrieval info: PRIVATE: SPREAD_FREQ_UNIT STRING "KHz"
    132                                              // Retrieval info: PRIVATE: PLL_ENA_CHECK STRING "0"
    133                                              // Retrieval info: PRIVATE: INCLK0_FREQ_EDIT STRING "50.000"
    134                                              // Retrieval info: PRIVATE: CNX_NO_COMPENSATE_RADIO STRING "0"
    135                                              // Retrieval info: PRIVATE: INT_FEEDBACK__MODE_RADIO STRING "1"
    136                                              // Retrieval info: PRIVATE: OUTPUT_FREQ0 STRING "25.000"
    137                                              // Retrieval info: PRIVATE: PRIMARY_CLK_COMBO STRING "inclk0"
    138                                              // Retrieval info: PRIVATE: CREATE_INCLK1_CHECK STRING "0"
    139                                              // Retrieval info: PRIVATE: SACN_INPUTS_CHECK STRING "0"
    140                                              // Retrieval info: PRIVATE: DEV_FAMILY STRING "Cyclone II"
    141                                              // Retrieval info: PRIVATE: SWITCHOVER_COUNT_EDIT NUMERIC "1"
    142                                              // Retrieval info: PRIVATE: SWITCHOVER_FEATURE_ENABLED STRING "1"
    143                                              // Retrieval info: PRIVATE: BANDWIDTH_PRESET STRING "Low"
    144                                              // Retrieval info: PRIVATE: GLOCKED_FEATURE_ENABLED STRING "1"
    145                                              // Retrieval info: PRIVATE: USE_CLKENA0 STRING "0"
    146                                              // Retrieval info: PRIVATE: LVDS_PHASE_SHIFT_UNIT0 STRING "deg"
    147                                              // Retrieval info: PRIVATE: CLKBAD_SWITCHOVER_CHECK STRING "0"
    148                                              // Retrieval info: PRIVATE: BANDWIDTH_USE_PRESET STRING "0"
    149                                              // Retrieval info: PRIVATE: PLL_LVDS_PLL_CHECK NUMERIC "0"
    150                                              // Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
    151                                              // Retrieval info: CONSTANT: CLK0_DUTY_CYCLE NUMERIC "50"
    152                                              // Retrieval info: CONSTANT: LPM_TYPE STRING "altpll"
    153                                              // Retrieval info: CONSTANT: CLK0_MULTIPLY_BY NUMERIC "1"
    154                                              // Retrieval info: CONSTANT: INCLK0_INPUT_FREQUENCY NUMERIC "20000"
    155                                              // Retrieval info: CONSTANT: CLK0_DIVIDE_BY NUMERIC "2"
    156                                              // Retrieval info: CONSTANT: PLL_TYPE STRING "FAST"
    157                                              // Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Cyclone II"
    158                                              // Retrieval info: CONSTANT: OPERATION_MODE STRING "NORMAL"
    159                                              // Retrieval info: CONSTANT: COMPENSATE_CLOCK STRING "CLK0"
    160                                              // Retrieval info: CONSTANT: CLK0_PHASE_SHIFT STRING "0"
    161                                              // Retrieval info: USED_PORT: c0 0 0 0 0 OUTPUT VCC "c0"
    162                                              // Retrieval info: USED_PORT: @clk 0 0 6 0 OUTPUT VCC "@clk[5..0]"
    163                                              // Retrieval info: USED_PORT: inclk0 0 0 0 0 INPUT GND "inclk0"
    164                                              // Retrieval info: USED_PORT: @extclk 0 0 4 0 OUTPUT VCC "@extclk[3..0]"
    165                                              // Retrieval info: CONNECT: @inclk 0 0 1 0 inclk0 0 0 0 0
    166                                              // Retrieval info: CONNECT: c0 0 0 0 0 @clk 0 0 1 0
    167                                              // Retrieval info: CONNECT: @inclk 0 0 1 1 GND 0 0 0 0
    168                                              // Retrieval info: GEN_FILE: TYPE_NORMAL VgaPll.v TRUE FALSE
    169                                              // Retrieval info: GEN_FILE: TYPE_NORMAL VgaPll.inc FALSE FALSE
    170                                              // Retrieval info: GEN_FILE: TYPE_NORMAL VgaPll.cmp FALSE FALSE
    171                                              // Retrieval info: GEN_FILE: TYPE_NORMAL VgaPll.bsf FALSE FALSE
    172                                              // Retrieval info: GEN_FILE: TYPE_NORMAL VgaPll_inst.v FALSE FALSE
    173                                              // Retrieval info: GEN_FILE: TYPE_NORMAL VgaPll_bb.v FALSE FALSE

Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                     16         7         9     43.75

================================Toggle Details================================

Toggle Coverage for File ../vga-core/vga_pll.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
         43                    clock_output_bus[5]           0           0                                0.00 
         43                    clock_output_bus[4]           0           0                                0.00 
         43                    clock_output_bus[3]           0           0                                0.00 
         43                    clock_output_bus[0]           1           0                               50.00 
         44                     clock_input_bus[1]           0           0                                0.00 

Total Node Count     =          8 
Toggled Node Count   =          3 
Untoggled Node Count =          5 

Toggle Coverage      =      43.75% (7 of 16 bins)

=================================================================================
=== File: circle.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                          228       189        39     82.89

================================Statement Details================================

Statement Coverage for file circle.sv --

    1                                                `define TOP_CORNER 2'b11
    2                                                `define BL_CORNER 2'b01
    3                                                `define BR_CORNER 2'b10
    4                                                
    5                                                module circle(input logic clk, input logic rst_n, input logic [2:0] colour,
    6                                                              input logic [7:0] centre_x, input logic [6:0] centre_y, input logic [7:0] radius,
    7                                                			  input logic [8:0] bounds_x, input logic [8:0] bounds_y, 
    8                                                			  input logic [8:0] bounds2_x, input logic [8:0] bounds2_y, 
    9                                                			  input logic [1:0] which_corner,
    10                                                             input logic start, output logic done,
    11                                                             output logic [7:0] vga_x, output logic [6:0] vga_y,
    12                                                             output logic [2:0] vga_colour, output logic vga_plot);
    13                                               	
    14                                               	//enumeration for all possible states
    15                                               	typedef enum { 
    16                                               		CIRCLE_WAIT, 
    17                                               		CIRCLE_CHECK_LOOP, 
    18                                               		CIRCLE_DRAW_PIXEL1,
    19                                               		CIRCLE_DRAW_PIXEL2,
    20                                               		CIRCLE_DRAW_PIXEL3,
    21                                               		CIRCLE_DRAW_PIXEL4, 
    22                                               		CIRCLE_DRAW_PIXEL5,
    23                                               		CIRCLE_DRAW_PIXEL6,
    24                                               		CIRCLE_DRAW_PIXEL7,
    25                                               		CIRCLE_DRAW_PIXEL8,
    26                                               		CIRCLE_CRIT_CHECK,
    27                                               		CIRCLE_CRIT_LE_ZERO,
    28                                               		CIRCLE_CRIT_GT_ZERO,
    29                                               		CIRCLE_DRAW_DONE
    30                                               	} state_t;
    31                                               
    32                                               	state_t curr_state;
    33                                               	state_t next_state;
    34                                               
    35                                               	logic [7:0] offset_x;
    36                                               	logic [6:0] offset_y;
    37                                               	logic signed [32:0] crit;
    38                                               	logic signed [32:0] next_crit;
    39                                               
    40                                                   logic [8:0] vga_x_logic;
    41                                                   logic [7:0] vga_y_logic;
    42                                               
    43                                               	logic update_offset_x;
    44                                               	logic update_offset_y;
    45                                               	logic update_crit;
    46                                               	logic which_crit;
    47                                               
    48                                                   // STATE MACHINE CLOCK LOGIC BLOCK
    49              1                       1923     	always @(posedge clk) begin
    50                                               		if(!rst_n) begin
    51              1                          3     			curr_state <= CIRCLE_WAIT;
    52                                               		end	else begin
    53              1                       1920     			curr_state <= next_state;
    54                                               		end
    55                                               	end
    56                                               
    57                                               	// offset_x register logic block
    58              1                        153     	always @(posedge clk) begin
    59                                               		if (!rst_n) begin
    60              1                          6                 offset_x <= radius;
    61                                                       end
    62                                                       else if (update_offset_x) begin
    63              1                         72                 offset_x <= offset_x - 1;
    64                                               		end
    65                                               	end
    66                                               
    67                                               	// offset_y register logic block
    68              1                        357     	always @(posedge clk) begin
    69                                               		if (!rst_n) begin
    70              1                          6                 offset_y <= 0;
    71                                                       end
    72                                                       else if (update_offset_y) begin
    73              1                        174                 offset_y <= offset_y + 1;
    74                                               		end
    75                                               	end
    76                                               
    77                                               	// crit register logic block
    78              1                        357     	always @(posedge clk) begin
    79                                               		if (!rst_n) begin
    80              1                          6                 crit <= 1 - radius;
    81                                                       end else if (update_crit) begin
    82              1                        174                 crit <= next_crit;
    83                                               		end
    84                                               	end
    85                                               
    86                                                   // STATE MACHINE OUTPUT LOGIC BLOCK
    87              1                       1931     	always_comb begin
    88                                               		case (curr_state)
    89                                               			CIRCLE_WAIT: begin
    90              1                          9     				done = 0;
    91              1                          9     				vga_plot = 0;
    92              1                          9     				vga_x_logic = 0;
    93              1                          9     				vga_y_logic = 0;
    94              1                          9     				update_offset_x = 0;
    95              1                          9     				update_offset_y = 0;
    96              1                          9     				update_crit = 0;
    97              1                          9     				which_crit = 0;
    98                                               				if (start) begin
    99              1                          3     					next_state = CIRCLE_CHECK_LOOP;
    100                                              				end else begin
    101             1                          6     					next_state = CIRCLE_WAIT;
    102                                              				end
    103                                              			end
    104                                              			CIRCLE_CHECK_LOOP: begin
    105             1                        177     				done = 0;
    106             1                        177     				vga_plot = 0;
    107             1                        177     				vga_x_logic = 0;
    108             1                        177     				vga_y_logic = 0;
    109             1                        177     				update_offset_x = 0;
    110             1                        177     				update_offset_y = 0;
    111             1                        177     				update_crit = 0;
    112             1                        177     				which_crit = 0;
    113                                              				if (offset_y <= offset_x) begin
    114             1                        174     					next_state = CIRCLE_DRAW_PIXEL1;
    115                                              				end else begin
    116             1                          3     					next_state = CIRCLE_DRAW_DONE;
    117                                              				end
    118                                              			end
    119                                              			CIRCLE_DRAW_PIXEL1: begin
    120             1                        174     				done = 0;
    121             1                        174     				update_offset_x = 0;
    122             1                        174     				update_offset_y = 0;
    123             1                        174     				update_crit = 0;
    124             1                        174     				which_crit = 0;
    125                                              
    126             1                        174     				vga_x_logic = centre_x + offset_x;
    127             1                        174     				vga_y_logic = centre_y + offset_y;
    128             1                        174     				next_state = CIRCLE_DRAW_PIXEL2;
    129                                              
    130                                              				// plot only if it is within bounds, edited for reuleaux
    131                                              				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    132                                              					if (which_corner == `TOP_CORNER) begin
    133                                              						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    134             1                    ***0***     							vga_plot = 1;
    135                                              						end else begin
    136             1                         49     							vga_plot = 0;
    137                                              						end
    138                                              					end else begin
    139             1                         37     						vga_plot = 0;
    140                                              					end
    141                                              					if (which_corner == `BL_CORNER) begin
    142                                              						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    143             1                          1     							vga_plot = 1;
    144                                              						end else begin
    145             1                         36     							vga_plot = 0;
    146                                              						end
    147                                              					end else begin
    148             1                         49     						vga_plot = 0;
    149                                              					end
    150                                              					if (which_corner == `BR_CORNER) begin
    151                                              						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    152             1                    ***0***     							vga_plot = 1;
    153                                              						end else begin
    154             1                    ***0***     							vga_plot = 0;
    155                                              						end
    156                                              					end else begin
    157             1                         86     						vga_plot = 0;
    158                                              					end
    159                                              				end else begin
    160             1                         88     					vga_plot = 0;
    161                                              				end
    162                                              			end
    163                                              			CIRCLE_DRAW_PIXEL2: begin
    164             1                        174     				done = 0;
    165             1                        174     				update_offset_x = 0;
    166             1                        174     				update_offset_y = 0;
    167             1                        174     				update_crit = 0;
    168             1                        174     				which_crit = 0;
    169                                              
    170             1                        174     				vga_x_logic = centre_x + offset_y;
    171             1                        174     				vga_y_logic = centre_y + offset_x;
    172             1                        174     				next_state = CIRCLE_DRAW_PIXEL3;
    173                                              
    174                                              				// plot only if it is within bounds, edited for reuleaux
    175                                              				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    176                                              					if (which_corner == `TOP_CORNER) begin
    177                                              						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    178             1                         40     							vga_plot = 1;
    179                                              						end else begin
    180             1                         18     							vga_plot = 0;
    181                                              						end
    182                                              					end else begin
    183             1                    ***0***     						vga_plot = 0;
    184                                              					end
    185                                              					if (which_corner == `BL_CORNER) begin
    186                                              						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    187             1                    ***0***     							vga_plot = 1;
    188                                              						end else begin
    189             1                    ***0***     							vga_plot = 0;
    190                                              						end
    191                                              					end else begin
    192             1                         58     						vga_plot = 0;
    193                                              					end
    194                                              					if (which_corner == `BR_CORNER) begin
    195                                              						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    196             1                    ***0***     							vga_plot = 1;
    197                                              						end else begin
    198             1                    ***0***     							vga_plot = 0;
    199                                              						end
    200                                              					end else begin
    201             1                         58     						vga_plot = 0;
    202                                              					end
    203                                              				end else begin
    204             1                        116     					vga_plot = 0;
    205                                              				end
    206                                              			end
    207                                              			CIRCLE_DRAW_PIXEL3: begin
    208             1                        174     				done = 0;
    209             1                        174     				update_offset_x = 0;
    210             1                        174     				update_offset_y = 0;
    211             1                        174     				update_crit = 0;
    212             1                        174     				which_crit = 0;
    213                                              
    214             1                        174     				vga_x_logic = centre_x - offset_x;
    215             1                        174     				vga_y_logic = centre_y + offset_y;
    216             1                        174     				next_state = CIRCLE_DRAW_PIXEL4;
    217                                              
    218                                              				// plot only if it is within bounds, edited for reuleaux
    219                                              				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    220                                              					if (which_corner == `TOP_CORNER) begin
    221                                              						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    222             1                    ***0***     							vga_plot = 1;
    223                                              						end else begin
    224             1                         58     							vga_plot = 0;
    225                                              						end
    226                                              					end else begin
    227             1                         37     						vga_plot = 0;
    228                                              					end
    229                                              					if (which_corner == `BL_CORNER) begin
    230                                              						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    231             1                    ***0***     							vga_plot = 1;
    232                                              						end else begin
    233             1                    ***0***     							vga_plot = 0;
    234                                              						end
    235                                              					end else begin
    236             1                         95     						vga_plot = 0;
    237                                              					end
    238                                              					if (which_corner == `BR_CORNER) begin
    239                                              						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    240             1                          1     							vga_plot = 1;
    241                                              						end else begin
    242             1                         36     							vga_plot = 0;
    243                                              						end
    244                                              					end else begin
    245             1                         58     						vga_plot = 0;
    246                                              					end
    247                                              				end else begin
    248             1                         79     					vga_plot = 0;
    249                                              				end
    250                                              			end
    251                                              			CIRCLE_DRAW_PIXEL4: begin
    252             1                        174     				done = 0;
    253             1                        174     				update_offset_x = 0;
    254             1                        174     				update_offset_y = 0;
    255             1                        174     				update_crit = 0;
    256             1                        174     				which_crit = 0;
    257                                              				
    258             1                        174     				vga_x_logic = centre_x - offset_y;
    259             1                        174     				vga_y_logic = centre_y + offset_x;
    260             1                        174     				next_state = CIRCLE_DRAW_PIXEL5;
    261                                              
    262                                              				// plot only if it is within bounds, edited for reuleaux
    263                                              				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    264                                              					if (which_corner == `TOP_CORNER) begin
    265                                              						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    266             1                         40     							vga_plot = 1;
    267                                              						end else begin
    268             1                         18     							vga_plot = 0;
    269                                              						end
    270                                              					end else begin
    271             1                    ***0***     						vga_plot = 0;
    272                                              					end
    273                                              					if (which_corner == `BL_CORNER) begin
    274                                              						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    275             1                    ***0***     							vga_plot = 1;
    276                                              						end else begin
    277             1                    ***0***     							vga_plot = 0;
    278                                              						end
    279                                              					end else begin
    280             1                         58     						vga_plot = 0;
    281                                              					end
    282                                              					if (which_corner == `BR_CORNER) begin
    283                                              						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    284             1                    ***0***     							vga_plot = 1;
    285                                              						end else begin
    286             1                    ***0***     							vga_plot = 0;
    287                                              						end
    288                                              					end else begin
    289             1                         58     						vga_plot = 0;
    290                                              					end
    291                                              				end else begin
    292             1                        116     					vga_plot = 0;
    293                                              				end
    294                                              			end
    295                                              			CIRCLE_DRAW_PIXEL5: begin
    296             1                        174     				done = 0;
    297             1                        174     				update_offset_x = 0;
    298             1                        174     				update_offset_y = 0;
    299             1                        174     				update_crit = 0;
    300             1                        174     				which_crit = 0;
    301                                              				
    302             1                        174     				vga_x_logic = centre_x - offset_x;
    303             1                        174     				vga_y_logic = centre_y - offset_y;
    304             1                        174     				next_state = CIRCLE_DRAW_PIXEL6;
    305                                              
    306                                              				// plot only if it is within bounds, edited for reuleaux
    307                                              				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    308                                              					if (which_corner == `TOP_CORNER) begin
    309                                              						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    310             1                    ***0***     							vga_plot = 1;
    311                                              						end else begin
    312             1                         14     							vga_plot = 0;
    313                                              						end
    314                                              					end else begin
    315             1                         58     						vga_plot = 0;
    316                                              					end
    317                                              					if (which_corner == `BL_CORNER) begin
    318                                              						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    319             1                    ***0***     							vga_plot = 1;
    320                                              						end else begin
    321             1                    ***0***     							vga_plot = 0;
    322                                              						end
    323                                              					end else begin
    324             1                         72     						vga_plot = 0;
    325                                              					end
    326                                              					if (which_corner == `BR_CORNER) begin
    327                                              						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    328             1                         58     							vga_plot = 1;
    329                                              						end else begin
    330             1                    ***0***     							vga_plot = 0;
    331                                              						end
    332                                              					end else begin
    333             1                         14     						vga_plot = 0;
    334                                              					end
    335                                              				end else begin
    336             1                        102     					vga_plot = 0;
    337                                              				end
    338                                              			end
    339                                              			CIRCLE_DRAW_PIXEL6: begin
    340             1                        174     				done = 0;
    341             1                        174     				update_offset_x = 0;
    342             1                        174     				update_offset_y = 0;
    343             1                        174     				update_crit = 0;
    344             1                        174     				which_crit = 0;
    345                                              				
    346             1                        174     				vga_x_logic = centre_x - offset_y;
    347             1                        174     				vga_y_logic = centre_y - offset_x;
    348             1                        174     				next_state = CIRCLE_DRAW_PIXEL7;
    349                                              
    350                                              				// plot only if it is within bounds, edited for reuleaux
    351                                              				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    352                                              					if (which_corner == `TOP_CORNER) begin
    353                                              						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    354             1                    ***0***     							vga_plot = 1;
    355                                              						end else begin
    356             1                    ***0***     							vga_plot = 0;
    357                                              						end
    358                                              					end else begin
    359             1                         99     						vga_plot = 0;
    360                                              					end
    361                                              					if (which_corner == `BL_CORNER) begin
    362                                              						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    363             1                    ***0***     							vga_plot = 1;
    364                                              						end else begin
    365             1                         41     							vga_plot = 0;
    366                                              						end
    367                                              					end else begin
    368             1                         58     						vga_plot = 0;
    369                                              					end
    370                                              					if (which_corner == `BR_CORNER) begin
    371                                              						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    372             1                         18     							vga_plot = 1;
    373                                              						end else begin
    374             1                         40     							vga_plot = 0;
    375                                              						end
    376                                              					end else begin
    377             1                         41     						vga_plot = 0;
    378                                              					end
    379                                              				end else begin
    380             1                         75     					vga_plot = 0;
    381                                              				end
    382                                              			end
    383                                              			CIRCLE_DRAW_PIXEL7: begin
    384             1                        174     				done = 0;
    385             1                        174     				update_offset_x = 0;
    386             1                        174     				update_offset_y = 0;
    387             1                        174     				update_crit = 0;
    388             1                        174     				which_crit = 0;
    389                                              				
    390             1                        174     				vga_x_logic = centre_x + offset_x;
    391             1                        174     				vga_y_logic = centre_y - offset_y;
    392             1                        174     				next_state = CIRCLE_DRAW_PIXEL8;
    393                                              
    394                                              				// plot only if it is within bounds, edited for reuleaux
    395                                              				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    396                                              					if (which_corner == `TOP_CORNER) begin
    397                                              						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    398             1                    ***0***     							vga_plot = 1;
    399                                              						end else begin
    400             1                          5     							vga_plot = 0;
    401                                              						end
    402                                              					end else begin
    403             1                         58     						vga_plot = 0;
    404                                              					end
    405                                              					if (which_corner == `BL_CORNER) begin
    406                                              						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    407             1                         58     							vga_plot = 1;
    408                                              						end else begin
    409             1                    ***0***     							vga_plot = 0;
    410                                              						end
    411                                              					end else begin
    412             1                          5     						vga_plot = 0;
    413                                              					end
    414                                              					if (which_corner == `BR_CORNER) begin
    415                                              						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    416             1                    ***0***     							vga_plot = 1;
    417                                              						end else begin
    418             1                    ***0***     							vga_plot = 0;
    419                                              						end
    420                                              					end else begin
    421             1                         63     						vga_plot = 0;
    422                                              					end
    423                                              				end else begin
    424             1                        111     					vga_plot = 0;
    425                                              				end
    426                                              			end
    427                                              			CIRCLE_DRAW_PIXEL8: begin
    428             1                        174     				done = 0;
    429             1                        174     				update_offset_x = 0;
    430             1                        174     				update_offset_y = 0;
    431             1                        174     				update_crit = 0;
    432             1                        174     				which_crit = 0;
    433                                              				
    434             1                        174     				vga_x_logic = centre_x + offset_y;
    435             1                        174     				vga_y_logic = centre_y - offset_x;
    436             1                        174     				next_state = CIRCLE_CRIT_CHECK;
    437                                              
    438                                              				// plot only if it is within bounds, edited for reuleaux
    439                                              				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    440                                              					if (which_corner == `TOP_CORNER) begin
    441                                              						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    442             1                    ***0***     							vga_plot = 1;
    443                                              						end else begin
    444             1                    ***0***     							vga_plot = 0;
    445                                              						end
    446                                              					end else begin
    447             1                         98     						vga_plot = 0;
    448                                              					end
    449                                              					if (which_corner == `BL_CORNER) begin
    450                                              						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    451             1                         18     							vga_plot = 1;
    452                                              						end else begin
    453             1                         40     							vga_plot = 0;
    454                                              						end
    455                                              					end else begin
    456             1                         40     						vga_plot = 0;
    457                                              					end
    458                                              					if (which_corner == `BR_CORNER) begin
    459                                              						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    460             1                    ***0***     							vga_plot = 1;
    461                                              						end else begin
    462             1                         40     							vga_plot = 0;
    463                                              						end
    464                                              					end else begin
    465             1                         58     						vga_plot = 0;
    466                                              					end
    467                                              				end else begin
    468             1                         76     					vga_plot = 0;
    469                                              				end
    470                                              			end
    471                                              			CIRCLE_CRIT_CHECK: begin
    472             1                        174     				vga_plot = 0;
    473             1                        174     				done = 0;
    474             1                        174     				vga_x_logic = 0;
    475             1                        174     				vga_y_logic = 0;
    476             1                        174     				update_offset_x = 0;
    477             1                        174     				update_offset_y = 1;
    478             1                        174     				update_crit = 0;
    479             1                        174     				which_crit = 0;
    480                                              
    481                                              				if (crit <= 0) begin
    482             1                        102     					next_state = CIRCLE_CRIT_LE_ZERO;
    483                                              				end else begin
    484             1                         72                 		next_state = CIRCLE_CRIT_GT_ZERO;
    485                                              				end
    486                                              			end
    487                                              			CIRCLE_CRIT_LE_ZERO: begin
    488             1                        102     				vga_plot = 0;
    489             1                        102     				done = 0;
    490             1                        102     				vga_x_logic = 0;
    491             1                        102     				vga_y_logic = 0;
    492             1                        102     				update_offset_x = 0;
    493             1                        102     				update_offset_y = 0;
    494             1                        102     				update_crit = 1;
    495             1                        102     				which_crit = 0;
    496                                              
    497             1                        102     				next_state <= CIRCLE_CHECK_LOOP;
    498                                              			end
    499                                              			CIRCLE_CRIT_GT_ZERO: begin
    500             1                         72     				vga_plot = 0;
    501             1                         72     				done = 0;
    502             1                         72     				vga_x_logic = 0;
    503             1                         72     				vga_y_logic = 0;
    504             1                         72     				update_offset_x = 1;
    505             1                         72     				update_offset_y = 0;
    506             1                         72     				update_crit = 1;
    507             1                         72     				which_crit = 1;
    508             1                         72     				next_state <= CIRCLE_CHECK_LOOP;
    509                                              			end
    510                                              			CIRCLE_DRAW_DONE: begin
    511             1                          5     				done = 1;
    512             1                          5     				vga_plot = 0;
    513             1                          5     				vga_x_logic = 0;
    514             1                          5     				vga_y_logic = 0;
    515             1                          5     				update_offset_x = 0;
    516             1                          5     				update_offset_y = 0;
    517             1                          5     				update_crit = 0;
    518             1                          5     				which_crit = 0;
    519                                              				if (start) begin
    520             1                          3     					next_state = CIRCLE_DRAW_DONE;
    521                                              				end else begin
    522             1                          2     					next_state = CIRCLE_WAIT;
    523                                              				end
    524                                              			end
    525                                              			default begin
    526                                              				//panic
    527             1                    ***0***     				done = 0;
    528             1                    ***0***     				vga_plot = 0;
    529             1                    ***0***     				vga_x_logic = 119;
    530             1                    ***0***     				vga_y_logic = 159;
    531             1                    ***0***     				update_offset_x = 0;
    532             1                    ***0***     				update_offset_y = 0;
    533             1                    ***0***     				update_crit = 0;
    534             1                    ***0***     				which_crit = 0;
    535             1                    ***0***     				next_state = CIRCLE_WAIT;
    536                                              			end
    537                                              		endcase
    538                                              
    539             1                       1931     		vga_colour = colour;
    540             1                       1931     		vga_x = vga_x_logic[7:0];
    541             1                       1931             vga_y = vga_y_logic[6:0];
    542             1                       1931     		next_crit = which_crit ? crit + (2 * (offset_y - offset_x)) + 1 : crit + (2 * offset_y) + 1;
    543                                              	end
    544                                              	 
    545                                              endmodule

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                       148       107        41     72.29

================================Branch Details================================

Branch Coverage for file circle.sv --

------------------------------------IF Branch------------------------------------
    50                                      1923     Count coming in to IF
    50              1                          3     		if(!rst_n) begin
    52              1                       1920     		end	else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    59                                       153     Count coming in to IF
    59              1                          6     		if (!rst_n) begin
    62              1                         72             else if (update_offset_x) begin
                                              75     All False Count
Branch totals: 3 hits of 3 branches = 100.00%

------------------------------------IF Branch------------------------------------
    69                                       357     Count coming in to IF
    69              1                          6     		if (!rst_n) begin
    72              1                        174             else if (update_offset_y) begin
                                             177     All False Count
Branch totals: 3 hits of 3 branches = 100.00%

------------------------------------IF Branch------------------------------------
    79                                       357     Count coming in to IF
    79              1                          6     		if (!rst_n) begin
    81              1                        174             end else if (update_crit) begin
                                             177     All False Count
Branch totals: 3 hits of 3 branches = 100.00%

------------------------------------CASE Branch------------------------------------
    88                                      1931     Count coming in to CASE
    89              1                          9     			CIRCLE_WAIT: begin
    104             1                        177     			CIRCLE_CHECK_LOOP: begin
    119             1                        174     			CIRCLE_DRAW_PIXEL1: begin
    163             1                        174     			CIRCLE_DRAW_PIXEL2: begin
    207             1                        174     			CIRCLE_DRAW_PIXEL3: begin
    251             1                        174     			CIRCLE_DRAW_PIXEL4: begin
    295             1                        174     			CIRCLE_DRAW_PIXEL5: begin
    339             1                        174     			CIRCLE_DRAW_PIXEL6: begin
    383             1                        174     			CIRCLE_DRAW_PIXEL7: begin
    427             1                        174     			CIRCLE_DRAW_PIXEL8: begin
    471             1                        174     			CIRCLE_CRIT_CHECK: begin
    487             1                        102     			CIRCLE_CRIT_LE_ZERO: begin
    499             1                         72     			CIRCLE_CRIT_GT_ZERO: begin
    510             1                          5     			CIRCLE_DRAW_DONE: begin
    525             1                    ***0***     			default begin
Branch totals: 14 hits of 15 branches = 93.33%

------------------------------------IF Branch------------------------------------
    98                                         9     Count coming in to IF
    98              1                          3     				if (start) begin
    100             1                          6     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    113                                      177     Count coming in to IF
    113             1                        174     				if (offset_y <= offset_x) begin
    115             1                          3     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    131                                      174     Count coming in to IF
    131             1                         86     				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    159             1                         88     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    132                                       86     Count coming in to IF
    132             1                         49     					if (which_corner == `TOP_CORNER) begin
    138             1                         37     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    133                                       49     Count coming in to IF
    133             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    135             1                         49     						end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    141                                       86     Count coming in to IF
    141             1                         37     					if (which_corner == `BL_CORNER) begin
    147             1                         49     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    142                                       37     Count coming in to IF
    142             1                          1     						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    144             1                         36     						end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    150                                       86     Count coming in to IF
    150             1                    ***0***     					if (which_corner == `BR_CORNER) begin
    156             1                         86     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    151                                  ***0***     Count coming in to IF
    151             1                    ***0***     						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    153             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    175                                      174     Count coming in to IF
    175             1                         58     				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    203             1                        116     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    176                                       58     Count coming in to IF
    176             1                         58     					if (which_corner == `TOP_CORNER) begin
    182             1                    ***0***     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    177                                       58     Count coming in to IF
    177             1                         40     						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    179             1                         18     						end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    185                                       58     Count coming in to IF
    185             1                    ***0***     					if (which_corner == `BL_CORNER) begin
    191             1                         58     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    186                                  ***0***     Count coming in to IF
    186             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    188             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    194                                       58     Count coming in to IF
    194             1                    ***0***     					if (which_corner == `BR_CORNER) begin
    200             1                         58     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    195                                  ***0***     Count coming in to IF
    195             1                    ***0***     						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    197             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    219                                      174     Count coming in to IF
    219             1                         95     				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    247             1                         79     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    220                                       95     Count coming in to IF
    220             1                         58     					if (which_corner == `TOP_CORNER) begin
    226             1                         37     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    221                                       58     Count coming in to IF
    221             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    223             1                         58     						end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    229                                       95     Count coming in to IF
    229             1                    ***0***     					if (which_corner == `BL_CORNER) begin
    235             1                         95     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    230                                  ***0***     Count coming in to IF
    230             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    232             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    238                                       95     Count coming in to IF
    238             1                         37     					if (which_corner == `BR_CORNER) begin
    244             1                         58     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    239                                       37     Count coming in to IF
    239             1                          1     						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    241             1                         36     						end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    263                                      174     Count coming in to IF
    263             1                         58     				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    291             1                        116     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    264                                       58     Count coming in to IF
    264             1                         58     					if (which_corner == `TOP_CORNER) begin
    270             1                    ***0***     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    265                                       58     Count coming in to IF
    265             1                         40     						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    267             1                         18     						end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    273                                       58     Count coming in to IF
    273             1                    ***0***     					if (which_corner == `BL_CORNER) begin
    279             1                         58     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    274                                  ***0***     Count coming in to IF
    274             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    276             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    282                                       58     Count coming in to IF
    282             1                    ***0***     					if (which_corner == `BR_CORNER) begin
    288             1                         58     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    283                                  ***0***     Count coming in to IF
    283             1                    ***0***     						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    285             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    307                                      174     Count coming in to IF
    307             1                         72     				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    335             1                        102     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    308                                       72     Count coming in to IF
    308             1                         14     					if (which_corner == `TOP_CORNER) begin
    314             1                         58     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    309                                       14     Count coming in to IF
    309             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    311             1                         14     						end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    317                                       72     Count coming in to IF
    317             1                    ***0***     					if (which_corner == `BL_CORNER) begin
    323             1                         72     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    318                                  ***0***     Count coming in to IF
    318             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    320             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    326                                       72     Count coming in to IF
    326             1                         58     					if (which_corner == `BR_CORNER) begin
    332             1                         14     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    327                                       58     Count coming in to IF
    327             1                         58     						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    329             1                    ***0***     						end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    351                                      174     Count coming in to IF
    351             1                         99     				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    379             1                         75     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    352                                       99     Count coming in to IF
    352             1                    ***0***     					if (which_corner == `TOP_CORNER) begin
    358             1                         99     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    353                                  ***0***     Count coming in to IF
    353             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    355             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    361                                       99     Count coming in to IF
    361             1                         41     					if (which_corner == `BL_CORNER) begin
    367             1                         58     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    362                                       41     Count coming in to IF
    362             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    364             1                         41     						end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    370                                       99     Count coming in to IF
    370             1                         58     					if (which_corner == `BR_CORNER) begin
    376             1                         41     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    371                                       58     Count coming in to IF
    371             1                         18     						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    373             1                         40     						end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    395                                      174     Count coming in to IF
    395             1                         63     				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    423             1                        111     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    396                                       63     Count coming in to IF
    396             1                          5     					if (which_corner == `TOP_CORNER) begin
    402             1                         58     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    397                                        5     Count coming in to IF
    397             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    399             1                          5     						end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    405                                       63     Count coming in to IF
    405             1                         58     					if (which_corner == `BL_CORNER) begin
    411             1                          5     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    406                                       58     Count coming in to IF
    406             1                         58     						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    408             1                    ***0***     						end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    414                                       63     Count coming in to IF
    414             1                    ***0***     					if (which_corner == `BR_CORNER) begin
    420             1                         63     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    415                                  ***0***     Count coming in to IF
    415             1                    ***0***     						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    417             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    439                                      174     Count coming in to IF
    439             1                         98     				if (vga_x_logic <= 9'd159 && vga_y_logic <= 8'd119) begin
    467             1                         76     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    440                                       98     Count coming in to IF
    440             1                    ***0***     					if (which_corner == `TOP_CORNER) begin
    446             1                         98     					end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    441                                  ***0***     Count coming in to IF
    441             1                    ***0***     						if (vga_x_logic >= bounds_x && vga_x_logic <= bounds2_x && vga_y_logic >= bounds2_y) begin
    443             1                    ***0***     						end else begin
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    449                                       98     Count coming in to IF
    449             1                         58     					if (which_corner == `BL_CORNER) begin
    455             1                         40     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    450                                       58     Count coming in to IF
    450             1                         18     						if (vga_x_logic >= bounds_x && vga_y_logic <= bounds2_y) begin
    452             1                         40     						end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    458                                       98     Count coming in to IF
    458             1                         40     					if (which_corner == `BR_CORNER) begin
    464             1                         58     					end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    459                                       40     Count coming in to IF
    459             1                    ***0***     						if (vga_x_logic <= bounds_x && vga_y_logic <= bounds2_y) begin
    461             1                         40     						end else begin
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    481                                      174     Count coming in to IF
    481             1                        102     				if (crit <= 0) begin
    483             1                         72     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    519                                        5     Count coming in to IF
    519             1                          3     				if (start) begin
    521             1                          2     				end else begin
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    542                                     1931     Count coming in to IF
    542             1                         72     		next_crit = which_crit ? crit + (2 * (offset_y - offset_x)) + 1 : crit + (2 * offset_y) + 1;
    542             2                       1859     		next_crit = which_crit ? crit + (2 * (offset_y - offset_x)) + 1 : crit + (2 * offset_y) + 1;
Branch totals: 2 hits of 2 branches = 100.00%


Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                    272       268         4     98.52

================================Toggle Details================================

Toggle Coverage for File circle.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
         32                             curr_state               ENUM type       Value       Count 
         33                             next_state               ENUM type       Value       Count 
         35                            offset_x[7]           0           0                                0.00 
         36                            offset_y[6]           0           0                                0.00 

Total Node Count     =        150 
Toggled Node Count   =        148 
Untoggled Node Count =          2 

Toggle Coverage      =      98.52% (268 of 272 bins)

=================================================================================
=== File: fillscreen.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                           10        10         0    100.00

================================Statement Details================================

Statement Coverage for file fillscreen.sv --

    1                                                module fillscreen(input logic clk, input logic rst_n, input logic [2:0] colour,
    2                                                                  input logic start, output logic done,
    3                                                                  output logic [7:0] vga_x, output logic [6:0] vga_y,
    4                                                                  output logic [2:0] vga_colour, output logic vga_plot);
    5                                                     // fill the screen
    6                                                	 logic [7:0] count_x;
    7                                                	 logic [6:0] count_y;
    8                                                	 
    9                                                	 assign vga_x = count_x;
    10                                               	 assign vga_y = count_y;
    11                                               	 
    12              1                      19206     	 always @(posedge clk)begin
    13                                               		if(!rst_n)
    14                                               			begin
    15              1                          4     				count_x <= 8'b11111111;
    16              1                          4     				count_y <= 7'd0;
    17              1                          4     				done <= 1'b0;
    18              1                          4     				vga_colour <= colour;
    19                                               			end
    20                                               		else if( count_x == 8'd159 && count_y == 7'd119 )
    21              1                          2     			done <= 1'b1;
    22                                               			
    23                                               		else if( start == 1'b1 && done == 1'b0)
    24                                               			begin
    25              1                      19200     				count_x <= count_x + 1'b1;
    26                                               				if (count_x == 8'd159) begin
    27              1                        119     					count_x <= 0;
    28              1                        119     					count_y <= count_y + 3'b001;
    29                                               				end
    30              1                      19200     				vga_plot <= 1'b1;
    31                                               			end		
    32                                               	 end
    33                                               	 
    34                                               endmodule
    35                                               

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                         6         5         1     83.33

================================Branch Details================================

Branch Coverage for file fillscreen.sv --

------------------------------------IF Branch------------------------------------
    13                                     19206     Count coming in to IF
    13              1                          4     		if(!rst_n)
    20              1                          2     		else if( count_x == 8'd159 && count_y == 7'd119 )
    23              1                      19200     		else if( start == 1'b1 && done == 1'b0)
                                         ***0***     All False Count
Branch totals: 3 hits of 4 branches = 75.00%

------------------------------------IF Branch------------------------------------
    26                                     19200     Count coming in to IF
    26              1                        119     				if (count_x == 8'd159) begin
                                           19081     All False Count
Branch totals: 2 hits of 2 branches = 100.00%


Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                     70        62         8     88.57

================================Toggle Details================================

Toggle Coverage for File fillscreen.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
          4                               vga_plot           0           0                                0.00 
          4                          vga_colour[2]           0           0                                0.00 
          4                          vga_colour[1]           0           0                                0.00 
          4                          vga_colour[0]           0           0                                0.00 

Total Node Count     =         35 
Toggled Node Count   =         31 
Untoggled Node Count =          4 

Toggle Coverage      =      88.57% (62 of 70 bins)

=================================================================================
=== File: reuleaux.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                          154       137        17     88.96

================================Statement Details================================

Statement Coverage for file reuleaux.sv --

    1                                                `define SQRT3_3xDiameter {8'b00101110 , 8'b00110000 }
    2                                                `define SQRT3_6xDiameter {8'b00010111 , 8'b00011000 }
    3                                                
    4                                                `define SQRT3_3 {8'b00000000 , 11'b10010011110 }
    5                                                `define SQRT3_6 {8'b00000000 , 11'b01001001111 }
    6                                                
    7                                                module reuleaux(input logic clk, input logic rst_n, input logic [2:0] colour,
    8                                                                input logic [7:0] centre_x, input logic [6:0] centre_y, input logic [7:0] diameter,
    9                                                                input logic start, output logic done,
    10                                                               output logic [7:0] vga_x, output logic [6:0] vga_y,
    11                                                               output logic [2:0] vga_colour, output logic vga_plot);
    12                                                    // draw the Reuleaux triangle
    13                                               
    14                                                    //Fixed Point Values
    15                                                    parameter FRAC_BITS = 11;
    16                                                    parameter INT_BITS = 8;
    17                                               
    18                                               
    19                                               
    20                                                    //Instantiating fillscreen (for Background)
    21                                                    logic bg_rst, bg_start, bg_done, bg_plot;
    22                                                    logic [2:0] bg_colour, bg_vga_colour;
    23                                                    logic [7:0] bg_vga_x;
    24                                                    logic [6:0] bg_vga_y;
    25                                               
    26                                                    
    27                                                    fillscreen bg(
    28                                                         .clk (clk), 
    29                                                         .rst_n (bg_rst), 
    30                                                         .colour (bg_colour),
    31                                                         .start (bg_start), 
    32                                                         .done (bg_done),
    33                                                         .vga_x (bg_vga_x), 
    34                                                         .vga_y (bg_vga_y),
    35                                                         .vga_colour (bg_vga_colour), 
    36                                                         .vga_plot ( bg_plot)
    37                                                         );
    38                                               
    39                                                    //Instantiating circle
    40                                                    logic circle_rst, circle_start, circle_done, circle_vga_plot;
    41                                                    logic [2:0] circle_colour, circle_vga_colour;
    42                                                    logic [7:0] circle_radius, circle_vga_x;
    43                                                    logic [6:0] circle_vga_y;
    44                                               
    45                                                    logic [FRAC_BITS + INT_BITS - 1:0] circle_center_x, circle_center_y, opposite_x1, opposite_y1, opposite_x2, opposite_y2;
    46                                                    logic [1:0] which_corner;
    47                                                    circle circleDraw(
    48                                                         .clk (clk), 
    49                                                         .rst_n (circle_rst), 
    50                                                         .colour (circle_colour),
    51                                                         .centre_x ( circle_center_x [INT_BITS + FRAC_BITS - 1: FRAC_BITS]), 
    52                                                         .centre_y ( circle_center_y [INT_BITS + FRAC_BITS - 1: FRAC_BITS]), 
    53                                                         .radius (circle_radius),
    54                                                         .start (circle_start), 
    55                                                         .done (circle_done),
    56                                                         .vga_x (circle_vga_x), 
    57                                                         .vga_y (circle_vga_y),
    58                                                         .vga_colour (circle_vga_colour), 
    59                                                         .vga_plot (circle_vga_plot),
    60                                                         //              0  ,18:11 
    61                                                         .bounds_x  ({1'b0 , opposite_x1 [INT_BITS + FRAC_BITS - 1: FRAC_BITS]}),
    62                                                         .bounds_y  ({1'b0 , opposite_y1 [INT_BITS + FRAC_BITS - 1: FRAC_BITS]}),
    63                                                         .bounds2_x ({1'b0 , opposite_x2 [INT_BITS + FRAC_BITS - 1: FRAC_BITS]}),
    64                                                         .bounds2_y ({1'b0 , opposite_y2 [INT_BITS + FRAC_BITS - 1: FRAC_BITS]}),
    65                                                         .which_corner (which_corner)
    66                                                         );
    67                                               
    68                                                    typedef enum { 
    69                                                         RESET_ST,
    70                                                         FILLBACKGROUND,
    71                                                         CIRCLE_WAIT1,
    72                                                         CIRCLE_DRAW1,
    73                                                         CIRCLE_WAIT2,
    74                                                         CIRCLE_DRAW2,
    75                                                         CIRCLE_WAIT3,
    76                                                         CIRCLE_DRAW3,
    77                                                         DONE
    78                                               	} state_t;
    79                                               
    80                                                    state_t curr_state;
    81                                               
    82                                                    //STATEMACHINE (Reset_ST state->Fill Background->Draw Circle 1->Draw Circle 2->Draw Circle 3->Done)
    83              1                         15          always @(posedge clk) begin
    84                                                         if(!rst_n) begin
    85              1                          1                    curr_state <= RESET_ST;
    86                                                         end
    87                                                         else 
    88                                                         case (curr_state)
    89                                                              RESET_ST:
    90                                                              begin
    91                                                                   if(start == 1)
    92                                                                   begin
    93              1                          1                              curr_state <= FILLBACKGROUND;
    94                                                                   end 
    95                                                                   else 
    96                                                                   begin
    97              1                    ***0***                              curr_state <= curr_state;
    98                                                                   end
    99                                                              end
    100                                                             FILLBACKGROUND:
    101                                                             begin
    102                                                                  if(bg_done == 1)
    103                                                                  begin
    104             1                          1                              curr_state <= CIRCLE_WAIT1;
    105                                                                  end 
    106                                                                  else 
    107                                                                  begin
    108             1                          1                              curr_state <= curr_state;
    109                                                                  end
    110                                                             end
    111                                                             CIRCLE_DRAW1:
    112                                                             begin 
    113                                                                  if(circle_done == 1)
    114                                                                  begin
    115             1                          1                              curr_state <= CIRCLE_WAIT2;
    116                                                                  end 
    117                                                                  else 
    118                                                                  begin
    119             1                          1                              curr_state <= curr_state;
    120                                                                  end
    121                                                             end
    122                                                             CIRCLE_DRAW2:
    123                                                             begin 
    124                                                                  if(circle_done == 1)
    125                                                                  begin
    126             1                          1                              curr_state <= CIRCLE_WAIT3;
    127                                                                  end 
    128                                                                  else 
    129                                                                  begin
    130             1                          1                              curr_state <= curr_state;
    131                                                                  end
    132                                                             end
    133                                                             CIRCLE_DRAW3:
    134                                                             begin 
    135                                                                  if(circle_done == 1)
    136                                                                  begin
    137             1                          1                              curr_state <= DONE;
    138                                                                  end 
    139                                                                  else 
    140                                                                  begin
    141             1                          1                              curr_state <= curr_state;
    142                                                                  end
    143                                                             end
    144                                                             DONE:
    145                                                             begin
    146             1                    ***0***                         curr_state <= curr_state;
    147                                                             end
    148                                                             CIRCLE_WAIT1:
    149                                                             begin
    150                                                                  if(circle_done == 0)
    151                                                                  begin
    152             1                          1                              curr_state <= CIRCLE_DRAW1;   
    153                                                                  end
    154                                                                  else 
    155                                                                  begin
    156             1                    ***0***                              curr_state <= curr_state; 
    157                                                                  end
    158                                                             end
    159                                                             CIRCLE_WAIT2:
    160                                                             begin
    161                                                                  if(circle_done == 0)
    162                                                                  begin
    163             1                          1                              curr_state <= CIRCLE_DRAW2;   
    164                                                                  end
    165                                                                  else 
    166                                                                  begin
    167             1                          1                              curr_state <= curr_state; 
    168                                                                  end
    169                                                             end
    170                                                             CIRCLE_WAIT3:
    171                                                             begin
    172                                                                  if(circle_done == 0)
    173                                                                  begin
    174             1                          1                              curr_state <= CIRCLE_DRAW3;   
    175                                                                  end
    176                                                                  else 
    177                                                                  begin
    178             1                          1                              curr_state <= curr_state; 
    179                                                                  end
    180                                                             end
    181                                                             default:
    182                                                             begin
    183             1                    ***0***                         curr_state <= RESET_ST;      
    184                                                             end
    185                                                        endcase
    186                                              	end
    187                                              
    188                                                   logic [29:0] sqrt3_6xdiameter;
    189                                                   logic [29:0] sqrt3_3xdiameter;
    190                                              
    191                                                   //Setting MACRO
    192                                                   //Bundle of signals that change
    193                                                   `define SIGBUNDLE {bg_rst, bg_start, bg_colour, circle_rst, circle_start, circle_colour, circle_radius}
    194                                                   //Coordinates of Right Corner
    195                                                   `define CORNERX1 {centre_x + (diameter >> 1), 11'b0};
    196                                                   `define CORNERY1 {1'b0, centre_y, 11'd0} + {sqrt3_6xdiameter [29:11]};
    197                                                   //Coordinates of Left Corner
    198                                                   `define CORNERX2 {centre_x - (diameter >> 1), 11'b0};
    199                                                   `define CORNERY2 {1'b0, centre_y, 11'd0} + {sqrt3_6xdiameter [29:11]};
    200                                                   //Coordinates of TOP Corner
    201                                                   `define CORNERX3 {centre_x, 11'b0};
    202                                                   `define CORNERY3 {1'b0, centre_y, 11'd0} - {sqrt3_3xdiameter [29:11]};
    203                                              
    204                                                   //Setting Signals
    205             1                      20769          always_comb begin : signalGenerator
    206             1                      20769               sqrt3_3xdiameter = ( `SQRT3_3 * {diameter, 11'd0});
    207             1                      20769               sqrt3_6xdiameter = ( `SQRT3_6 * {diameter, 11'd0});
    208                                                        case (curr_state)
    209                                                             //                                    {bg_rst, bg_start, bg_colour, circle_rst, circle_start, circle_colour, circle_radius}                          
    210                                                             RESET_ST:      begin
    211             1                          3                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b0      , 1'b0        , 3'b100       , diameter  };
    212             1                          3                                        circle_center_x = 16'd0;
    213             1                          3                                        circle_center_y = 16'd0;
    214             1                          3                                        opposite_x1     = 16'd0;
    215             1                          3                                        opposite_y1     = 16'd0;
    216             1                          3                                        opposite_x2     = 16'd0;
    217             1                          3                                        opposite_y2     = 16'd0;
    218             1                          3                                        which_corner = 2'b00;
    219             1                          3                                        vga_x =     bg_vga_x;
    220             1                          3                                        vga_y =     bg_vga_y;
    221             1                          3                                        vga_colour= bg_vga_colour;
    222             1                          3                                        vga_plot=   bg_plot;
    223             1                          3                                        done = 1'b0;
    224                                                                            end
    225                                                             FILLBACKGROUND:begin
    226             1                      19201                                        `SIGBUNDLE      = {1'b1  , 1'b1    , 3'b000   , 1'b0      , 1'b0        , 3'b100       , diameter  };
    227             1                      19201                                        circle_center_x = 16'd0;
    228             1                      19201                                        circle_center_y = 16'd0;
    229             1                      19201                                        opposite_x1     = 16'd0;
    230             1                      19201                                        opposite_y1     = 16'd0;
    231             1                      19201                                        opposite_x2     = 16'd0;
    232             1                      19201                                        opposite_y2     = 16'd0;
    233             1                      19201                                        which_corner = 2'b00;
    234             1                      19201                                        vga_x =     bg_vga_x;
    235             1                      19201                                        vga_y =     bg_vga_y;
    236             1                      19201                                        vga_colour= bg_vga_colour;
    237             1                      19201                                        vga_plot=   bg_plot;
    238             1                      19201                                        done = 1'b0;                                   
    239                                                                            end
    240                                                             CIRCLE_WAIT1:  begin
    241             1                          1                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b0      , 1'b0        , 3'b100       , diameter  };
    242             1                          1                                        circle_center_x = `CORNERX1;
    243             1                          1                                        circle_center_y = `CORNERY1;
    244                                                                                 //Opposing Corner 1
    245             1                          1                                        opposite_x1     = `CORNERX3;
    246             1                          1                                        opposite_y1     = `CORNERY3;
    247                                                                                 //Opposing Corner 2
    248             1                          1                                        opposite_x2     = `CORNERX2;
    249             1                          1                                        opposite_y2     = `CORNERY2;
    250             1                          1                                        which_corner = 2'b10;
    251             1                          1                                        vga_x =     circle_vga_x;
    252             1                          1                                        vga_y =     circle_vga_y;
    253             1                          1                                        vga_colour= circle_vga_colour;
    254             1                          1                                        vga_plot=   circle_vga_plot;
    255             1                          1                                        done = 1'b0;
    256                                                                            end
    257                                                             CIRCLE_WAIT2:  begin
    258             1                          2                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b0      , 1'b0        , 3'b100       , diameter  };
    259             1                          2                                        circle_center_x = `CORNERX2;
    260             1                          2                                        circle_center_y = `CORNERY2;
    261                                                                                 //Opposing Corner 1
    262             1                          2                                        opposite_x1     = `CORNERX3;
    263             1                          2                                        opposite_y1     = `CORNERY3;
    264                                                                                 //Opposing Corner 2
    265             1                          2                                        opposite_x2     = `CORNERX1;
    266             1                          2                                        opposite_y2     = `CORNERY1;
    267             1                          2                                        which_corner = 2'b01;
    268             1                          2                                        vga_x =     circle_vga_x;
    269             1                          2                                        vga_y =     circle_vga_y;
    270             1                          2                                        vga_colour= circle_vga_colour;
    271             1                          2                                        vga_plot=   circle_vga_plot;
    272             1                          2                                        done = 1'b0;
    273                                                                            end 
    274                                                             CIRCLE_WAIT3:  begin
    275             1                          2                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b0      , 1'b0        , 3'b100       , diameter  };
    276             1                          2                                        circle_center_x = `CORNERX3;
    277             1                          2                                        circle_center_y = `CORNERY3;
    278                                                                                 //Opposing Corner 1
    279             1                          2                                        opposite_x1     = `CORNERX2;
    280             1                          2                                        opposite_y1     = `CORNERY2;
    281                                                                                 //Opposing Corner 2
    282             1                          2                                        opposite_x2     = `CORNERX1;
    283             1                          2                                        opposite_y2     = `CORNERY1;
    284             1                          2                                        which_corner = 2'b11;
    285             1                          2                                        which_corner = 2'b00;
    286             1                          2                                        vga_x =     circle_vga_x;
    287             1                          2                                        vga_y =     circle_vga_y;
    288             1                          2                                        vga_colour= circle_vga_colour;
    289             1                          2                                        vga_plot=   circle_vga_plot;
    290             1                          2                                        done = 1'b0;
    291                                                                            end     
    292                                                             CIRCLE_DRAW1:  begin
    293             1                        520                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b1      , 1'b1        , 3'b001       , diameter  };
    294                                                                                 //x = 120 ; y = 83.1
    295             1                        520                                        circle_center_x = `CORNERX1;
    296             1                        520                                        circle_center_y = `CORNERY1;
    297                                                                                 //Opposing Corner 1
    298             1                        520                                        opposite_x1     = `CORNERX3;
    299             1                        520                                        opposite_y1     = `CORNERY3;
    300                                                                                 //Opposing Corner 2
    301             1                        520                                        opposite_x2     = `CORNERX2;
    302             1                        520                                        opposite_y2     = `CORNERY2;
    303             1                        520                                        which_corner = 2'b10;
    304             1                        520                                        vga_x =     circle_vga_x;
    305             1                        520                                        vga_y =     circle_vga_y;
    306             1                        520                                        vga_colour= circle_vga_colour;
    307             1                        520                                        vga_plot=   circle_vga_plot;
    308             1                        520                                        done = 1'b0;
    309                                                                            end           
    310                                                             CIRCLE_DRAW2:  begin
    311             1                        520                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b1      , 1'b1        , 3'b010       , diameter  };
    312                                                                                 //x = 40 ; y = 83.1
    313             1                        520                                        circle_center_x = `CORNERX2;
    314             1                        520                                        circle_center_y = `CORNERY2;
    315                                                                                 //Opposing Corner 1
    316             1                        520                                        opposite_x1     = `CORNERX3;
    317             1                        520                                        opposite_y1     = `CORNERY3;
    318                                                                                 //Opposing Corner 2
    319             1                        520                                        opposite_x2     = `CORNERX1;
    320             1                        520                                        opposite_y2     = `CORNERY1;
    321             1                        520                                        which_corner = 2'b01;
    322             1                        520                                        vga_x =     circle_vga_x;
    323             1                        520                                        vga_y =     circle_vga_y;
    324             1                        520                                        vga_colour= circle_vga_colour;
    325             1                        520                                        vga_plot=   circle_vga_plot;
    326             1                        520                                        done = 1'b0;
    327                                                                            end       
    328                                                             CIRCLE_DRAW3:  begin
    329             1                        519                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b1      , 1'b1        , 3'b100       , diameter  };
    330                                                                                 //x = 80  ; y = 13.8
    331             1                        519                                        circle_center_x = `CORNERX3;
    332             1                        519                                        circle_center_y = `CORNERY3;
    333                                                                                 //Opposing Corner 1
    334             1                        519                                        opposite_x1     = `CORNERX2;
    335             1                        519                                        opposite_y1     = `CORNERY2;
    336                                                                                 //Opposing Corner 2
    337             1                        519                                        opposite_x2     = `CORNERX1;
    338             1                        519                                        opposite_y2     = `CORNERY1;
    339             1                        519                                        which_corner = 2'b11;
    340             1                        519                                        vga_x =     circle_vga_x;
    341             1                        519                                        vga_y =     circle_vga_y;
    342             1                        519                                        vga_colour= circle_vga_colour;
    343             1                        519                                        vga_plot=   circle_vga_plot;
    344             1                        519                                        done = 1'b0;
    345                                                                            end       
    346                                                             DONE:          begin
    347             1                          1                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b0      , 1'b0        , 3'b111       , diameter  };
    348             1                          1                                        circle_center_x = 16'd0;
    349             1                          1                                        circle_center_y = 16'd0;
    350             1                          1                                        opposite_x1     = 16'd0;
    351             1                          1                                        opposite_y1     = 16'd0;
    352             1                          1                                        opposite_x2     = 16'd0;
    353             1                          1                                        opposite_y2     = 16'd0;
    354             1                          1                                        which_corner = 2'b00;
    355             1                          1                                        vga_x =     8'd0;
    356             1                          1                                        vga_y =     7'd0;
    357             1                          1                                        vga_colour= 3'd0;
    358             1                          1                                        vga_plot=   1'd0;
    359             1                          1                                        done = 1'b1;
    360                                                                            end
    361                                                        default:            begin
    362             1                    ***0***                                        `SIGBUNDLE      = {1'b0  , 1'b0    , 3'b000   , 1'b0      , 1'b0        , 3'b111       , diameter  };
    363             1                    ***0***                                        circle_center_x = 16'd0;
    364             1                    ***0***                                        circle_center_y = 16'd0;
    365             1                    ***0***                                        opposite_x1     = 16'd0;
    366             1                    ***0***                                        opposite_y1     = 16'd0;
    367             1                    ***0***                                        opposite_x2     = 16'd0;
    368             1                    ***0***                                        opposite_y2     = 16'd0;
    369             1                    ***0***                                        which_corner = 2'b00;
    370             1                    ***0***                                        vga_x =     8'd0;
    371             1                    ***0***                                        vga_y =     7'd0;
    372             1                    ***0***                                        vga_colour= 3'd0;
    373             1                    ***0***                                        vga_plot=   1'd0;
    374             1                    ***0***                                        done = 1'b0;
    375                                                                            end
    376                                                             
    377                                                        endcase
    378                                                   end
    379                                              
    380                                              
    381                                              endmodule
    382                                              

Branch Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Branches                        38        33         5     86.84

================================Branch Details================================

Branch Coverage for file reuleaux.sv --

------------------------------------IF Branch------------------------------------
    84                                        15     Count coming in to IF
    84              1                          1               if(!rst_n) begin
    87              1                         14               else 
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------CASE Branch------------------------------------
    88                                        14     Count coming in to CASE
    89              1                          1                    RESET_ST:
    100             1                          2                    FILLBACKGROUND:
    111             1                          2                    CIRCLE_DRAW1:
    122             1                          2                    CIRCLE_DRAW2:
    133             1                          2                    CIRCLE_DRAW3:
    144             1                    ***0***                    DONE:
    148             1                          1                    CIRCLE_WAIT1:
    159             1                          2                    CIRCLE_WAIT2:
    170             1                          2                    CIRCLE_WAIT3:
    181             1                    ***0***                    default:
Branch totals: 8 hits of 10 branches = 80.00%

------------------------------------IF Branch------------------------------------
    91                                         1     Count coming in to IF
    91              1                          1                         if(start == 1)
    95              1                    ***0***                         else 
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    102                                        2     Count coming in to IF
    102             1                          1                         if(bg_done == 1)
    106             1                          1                         else 
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    113                                        2     Count coming in to IF
    113             1                          1                         if(circle_done == 1)
    117             1                          1                         else 
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    124                                        2     Count coming in to IF
    124             1                          1                         if(circle_done == 1)
    128             1                          1                         else 
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    135                                        2     Count coming in to IF
    135             1                          1                         if(circle_done == 1)
    139             1                          1                         else 
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    150                                        1     Count coming in to IF
    150             1                          1                         if(circle_done == 0)
    154             1                    ***0***                         else 
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    161                                        2     Count coming in to IF
    161             1                          1                         if(circle_done == 0)
    165             1                          1                         else 
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    172                                        2     Count coming in to IF
    172             1                          1                         if(circle_done == 0)
    176             1                          1                         else 
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------CASE Branch------------------------------------
    208                                    20769     Count coming in to CASE
    210             1                          3                    RESET_ST:      begin
    225             1                      19201                    FILLBACKGROUND:begin
    240             1                          1                    CIRCLE_WAIT1:  begin
    257             1                          2                    CIRCLE_WAIT2:  begin
    274             1                          2                    CIRCLE_WAIT3:  begin
    292             1                        520                    CIRCLE_DRAW1:  begin
    310             1                        520                    CIRCLE_DRAW2:  begin
    328             1                        519                    CIRCLE_DRAW3:  begin
    346             1                          1                    DONE:          begin
    361             1                    ***0***               default:            begin
Branch totals: 9 hits of 10 branches = 90.00%


Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                    517       190       327     36.75

================================Toggle Details================================

Toggle Coverage for File reuleaux.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
          9                                   done           0           0                                0.00 
         21                                bg_plot           0           0                                0.00 
         22                       bg_vga_colour[2]           0           0                                0.00 
         22                       bg_vga_colour[1]           0           0                                0.00 
         22                       bg_vga_colour[0]           0           0                                0.00 
         22                           bg_colour[2]           0           0                                0.00 
         22                           bg_colour[1]           0           0                                0.00 
         22                           bg_colour[0]           0           0                                0.00 
         42                       circle_radius[7]           0           0                                0.00 
         42                       circle_radius[6]           0           0                                0.00 
         42                       circle_radius[5]           0           0                                0.00 
         42                       circle_radius[4]           0           0                                0.00 
         42                       circle_radius[3]           0           0                                0.00 
         42                       circle_radius[2]           0           0                                0.00 
         42                       circle_radius[1]           0           0                                0.00 
         42                       circle_radius[0]           0           0                                0.00 
         45                         opposite_y2[9]           0           0                                0.00 
         45                         opposite_y2[8]           0           0                                0.00 
         45                         opposite_y2[7]           0           1                               50.00 
         45                         opposite_y2[6]           0           0                                0.00 
         45                         opposite_y2[5]           0           1                               50.00 
         45                         opposite_y2[4]           0           1                               50.00 
         45                         opposite_y2[3]           0           0                                0.00 
         45                         opposite_y2[2]           0           0                                0.00 
         45                         opposite_y2[1]           0           0                                0.00 
         45                        opposite_y2[18]           0           0                                0.00 
         45                        opposite_y2[17]           0           1                               50.00 
         45                        opposite_y2[16]           0           0                                0.00 
         45                        opposite_y2[15]           0           1                               50.00 
         45                        opposite_y2[14]           0           0                                0.00 
         45                        opposite_y2[13]           0           0                                0.00 
         45                        opposite_y2[12]           0           1                               50.00 
         45                        opposite_y2[11]           0           1                               50.00 
         45                        opposite_y2[10]           0           0                                0.00 
         45                         opposite_y2[0]           0           0                                0.00 
         45                         opposite_y1[8]           0           0                                0.00 
         45                         opposite_y1[7]           0           1                               50.00 
         45                         opposite_y1[6]           0           0                                0.00 
         45                         opposite_y1[5]           0           1                               50.00 
         45                         opposite_y1[4]           0           1                               50.00 
         45                         opposite_y1[3]           0           0                                0.00 
         45                         opposite_y1[2]           0           0                                0.00 
         45                         opposite_y1[1]           0           0                                0.00 
         45                        opposite_y1[18]           0           0                                0.00 
         45                        opposite_y1[17]           0           1                               50.00 
         45                        opposite_y1[16]           0           0                                0.00 
         45                        opposite_y1[15]           0           1                               50.00 
         45                        opposite_y1[12]           0           1                               50.00 
         45                        opposite_y1[11]           0           1                               50.00 
         45                         opposite_y1[0]           0           0                                0.00 
         45                         opposite_x2[9]           0           0                                0.00 
         45                         opposite_x2[8]           0           0                                0.00 
         45                         opposite_x2[7]           0           0                                0.00 
         45                         opposite_x2[6]           0           0                                0.00 
         45                         opposite_x2[5]           0           0                                0.00 
         45                         opposite_x2[4]           0           0                                0.00 
         45                         opposite_x2[3]           0           0                                0.00 
         45                         opposite_x2[2]           0           0                                0.00 
         45                         opposite_x2[1]           0           0                                0.00 
         45                        opposite_x2[18]           0           0                                0.00 
         45                        opposite_x2[17]           0           1                               50.00 
         45                        opposite_x2[16]           0           1                               50.00 
         45                        opposite_x2[15]           0           1                               50.00 
         45                        opposite_x2[14]           0           1                               50.00 
         45                        opposite_x2[13]           0           0                                0.00 
         45                        opposite_x2[12]           0           0                                0.00 
         45                        opposite_x2[11]           0           0                                0.00 
         45                        opposite_x2[10]           0           0                                0.00 
         45                         opposite_x2[0]           0           0                                0.00 
         45                         opposite_x1[9]           0           0                                0.00 
         45                         opposite_x1[8]           0           0                                0.00 
         45                         opposite_x1[7]           0           0                                0.00 
         45                         opposite_x1[6]           0           0                                0.00 
         45                         opposite_x1[5]           0           0                                0.00 
         45                         opposite_x1[4]           0           0                                0.00 
         45                         opposite_x1[3]           0           0                                0.00 
         45                         opposite_x1[2]           0           0                                0.00 
         45                         opposite_x1[1]           0           0                                0.00 
         45                        opposite_x1[18]           0           0                                0.00 
         45                        opposite_x1[16]           0           1                               50.00 
         45                        opposite_x1[14]           0           1                               50.00 
         45                        opposite_x1[13]           0           0                                0.00 
         45                        opposite_x1[12]           0           0                                0.00 
         45                        opposite_x1[11]           0           0                                0.00 
         45                        opposite_x1[10]           0           0                                0.00 
         45                         opposite_x1[0]           0           0                                0.00 
         45                     circle_center_y[9]           0           1                               50.00 
         45                     circle_center_y[8]           0           0                                0.00 
         45                     circle_center_y[7]           0           1                               50.00 
         45                     circle_center_y[6]           0           0                                0.00 
         45                     circle_center_y[5]           0           1                               50.00 
         45                     circle_center_y[3]           0           0                                0.00 
         45                     circle_center_y[2]           0           0                                0.00 
         45                     circle_center_y[1]           0           0                                0.00 
         45                    circle_center_y[18]           0           0                                0.00 
         45                    circle_center_y[16]           0           0                                0.00 
         45                    circle_center_y[14]           0           1                               50.00 
         45                    circle_center_y[13]           0           1                               50.00 
         45                    circle_center_y[11]           0           1                               50.00 
         45                    circle_center_y[10]           0           1                               50.00 
         45                     circle_center_y[0]           0           0                                0.00 
         45                     circle_center_x[9]           0           0                                0.00 
         45                     circle_center_x[8]           0           0                                0.00 
         45                     circle_center_x[7]           0           0                                0.00 
         45                     circle_center_x[6]           0           0                                0.00 
         45                     circle_center_x[5]           0           0                                0.00 
         45                     circle_center_x[4]           0           0                                0.00 
         45                     circle_center_x[3]           0           0                                0.00 
         45                     circle_center_x[2]           0           0                                0.00 
         45                     circle_center_x[1]           0           0                                0.00 
         45                    circle_center_x[18]           0           0                                0.00 
         45                    circle_center_x[13]           0           0                                0.00 
         45                    circle_center_x[12]           0           0                                0.00 
         45                    circle_center_x[11]           0           0                                0.00 
         45                    circle_center_x[10]           0           0                                0.00 
         45                     circle_center_x[0]           0           0                                0.00 
         80                             curr_state               ENUM type       Value       Count 
                                                                  RESET_ST           0        0.00 
                                                                      DONE           0        0.00 
        188                    sqrt3_6xdiameter[9]           0           0                                0.00 
        188                    sqrt3_6xdiameter[8]           0           0                                0.00 
        188                    sqrt3_6xdiameter[7]           0           0                                0.00 
        188                    sqrt3_6xdiameter[6]           0           0                                0.00 
        188                    sqrt3_6xdiameter[5]           0           0                                0.00 
        188                    sqrt3_6xdiameter[4]           0           0                                0.00 
        188                    sqrt3_6xdiameter[3]           0           0                                0.00 
        188                    sqrt3_6xdiameter[2]           0           0                                0.00 
        188                   sqrt3_6xdiameter[29]           0           0                                0.00 
        188                   sqrt3_6xdiameter[28]           0           0                                0.00 
        188                   sqrt3_6xdiameter[27]           0           0                                0.00 
        188                   sqrt3_6xdiameter[26]           0           0                                0.00 
        188                   sqrt3_6xdiameter[25]           0           0                                0.00 
        188                   sqrt3_6xdiameter[24]           0           0                                0.00 
        188                   sqrt3_6xdiameter[23]           0           0                                0.00 
        188                   sqrt3_6xdiameter[22]           0           0                                0.00 
        188                   sqrt3_6xdiameter[21]           0           0                                0.00 
        188                   sqrt3_6xdiameter[20]           0           0                                0.00 
        188                    sqrt3_6xdiameter[1]           0           0                                0.00 
        188                   sqrt3_6xdiameter[19]           0           0                                0.00 
        188                   sqrt3_6xdiameter[18]           0           0                                0.00 
        188                   sqrt3_6xdiameter[17]           0           0                                0.00 
        188                   sqrt3_6xdiameter[16]           0           0                                0.00 
        188                   sqrt3_6xdiameter[15]           0           0                                0.00 
        188                   sqrt3_6xdiameter[14]           0           0                                0.00 
        188                   sqrt3_6xdiameter[13]           0           0                                0.00 
        188                   sqrt3_6xdiameter[12]           0           0                                0.00 
        188                   sqrt3_6xdiameter[11]           0           0                                0.00 
        188                   sqrt3_6xdiameter[10]           0           0                                0.00 
        188                    sqrt3_6xdiameter[0]           0           0                                0.00 
        189                    sqrt3_3xdiameter[9]           0           0                                0.00 
        189                    sqrt3_3xdiameter[8]           0           0                                0.00 
        189                    sqrt3_3xdiameter[7]           0           0                                0.00 
        189                    sqrt3_3xdiameter[6]           0           0                                0.00 
        189                    sqrt3_3xdiameter[5]           0           0                                0.00 
        189                    sqrt3_3xdiameter[4]           0           0                                0.00 
        189                    sqrt3_3xdiameter[3]           0           0                                0.00 
        189                    sqrt3_3xdiameter[2]           0           0                                0.00 
        189                   sqrt3_3xdiameter[29]           0           0                                0.00 
        189                   sqrt3_3xdiameter[28]           0           0                                0.00 
        189                   sqrt3_3xdiameter[27]           0           0                                0.00 
        189                   sqrt3_3xdiameter[26]           0           0                                0.00 
        189                   sqrt3_3xdiameter[25]           0           0                                0.00 
        189                   sqrt3_3xdiameter[24]           0           0                                0.00 
        189                   sqrt3_3xdiameter[23]           0           0                                0.00 
        189                   sqrt3_3xdiameter[22]           0           0                                0.00 
        189                   sqrt3_3xdiameter[21]           0           0                                0.00 
        189                   sqrt3_3xdiameter[20]           0           0                                0.00 
        189                    sqrt3_3xdiameter[1]           0           0                                0.00 
        189                   sqrt3_3xdiameter[19]           0           0                                0.00 
        189                   sqrt3_3xdiameter[18]           0           0                                0.00 
        189                   sqrt3_3xdiameter[17]           0           0                                0.00 
        189                   sqrt3_3xdiameter[16]           0           0                                0.00 
        189                   sqrt3_3xdiameter[15]           0           0                                0.00 
        189                   sqrt3_3xdiameter[14]           0           0                                0.00 
        189                   sqrt3_3xdiameter[13]           0           0                                0.00 
        189                   sqrt3_3xdiameter[12]           0           0                                0.00 
        189                   sqrt3_3xdiameter[11]           0           0                                0.00 
        189                   sqrt3_3xdiameter[10]           0           0                                0.00 
        189                    sqrt3_3xdiameter[0]           0           0                                0.00 

Total Node Count     =        263 
Toggled Node Count   =         85 
Untoggled Node Count =        178 

Toggle Coverage      =      36.75% (190 of 517 bins)

=================================================================================
=== File: task4.sv
=================================================================================
Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                    116        39        77     33.62

================================Toggle Details================================

Toggle Coverage for File task4.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
          3                                LEDR[9]           0           0                                0.00 
          3                                LEDR[8]           0           0                                0.00 
          3                                LEDR[7]           0           0                                0.00 
          3                                LEDR[6]           0           0                                0.00 
          3                                LEDR[5]           0           0                                0.00 
          3                                LEDR[4]           0           0                                0.00 
          3                                LEDR[3]           0           0                                0.00 
          3                                LEDR[2]           0           0                                0.00 
          3                                LEDR[1]           0           0                                0.00 
          3                                LEDR[0]           0           0                                0.00 
          6                               VGA_R[7]           0           0                                0.00 
          6                               VGA_R[6]           0           0                                0.00 
          6                               VGA_R[5]           0           0                                0.00 
          6                               VGA_R[4]           0           0                                0.00 
          6                               VGA_R[3]           0           0                                0.00 
          6                               VGA_R[2]           0           0                                0.00 
          6                               VGA_R[1]           0           0                                0.00 
          6                               VGA_R[0]           0           0                                0.00 
          6                               VGA_G[7]           0           0                                0.00 
          6                               VGA_G[6]           0           0                                0.00 
          6                               VGA_G[5]           0           0                                0.00 
          6                               VGA_G[4]           0           0                                0.00 
          6                               VGA_G[3]           0           0                                0.00 
          6                               VGA_G[2]           0           0                                0.00 
          6                               VGA_G[1]           0           0                                0.00 
          6                               VGA_G[0]           0           0                                0.00 
          6                               VGA_B[7]           0           0                                0.00 
          6                               VGA_B[6]           0           0                                0.00 
          6                               VGA_B[5]           0           0                                0.00 
          6                               VGA_B[4]           0           0                                0.00 
          6                               VGA_B[3]           0           0                                0.00 
          6                               VGA_B[2]           0           0                                0.00 
          6                               VGA_B[1]           0           0                                0.00 
          6                               VGA_B[0]           0           0                                0.00 
          7                                 VGA_VS           0           0                                0.00 
          7                                 VGA_HS           0           0                                0.00 
          7                                VGA_CLK           1           0                               50.00 
         22                               VGA_SYNC           0           0                                0.00 
         23                              VGA_BLANK           0           0                                0.00 

Total Node Count     =         58 
Toggled Node Count   =         19 
Untoggled Node Count =         39 

Toggle Coverage      =      33.62% (39 of 116 bins)

=================================================================================
=== File: tb_task4.sv
=================================================================================
Statement Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Stmts                            9         9         0    100.00

================================Statement Details================================

Statement Coverage for file tb_task4.sv --

    1                                                `timescale 1ps/1ps
    2                                                module tb_task4();
    3                                                
    4                                                    logic CLOCK_50 = 0; 
    5                                                    logic [3:0] KEY;
    6                                                    logic [9:0] SW; 
    7                                                    logic [9:0] LEDR;
    8                                                    logic [6:0] HEX0; 
    9                                                    logic [6:0] HEX1; 
    10                                                   logic [6:0] HEX2;
    11                                                   logic [6:0] HEX3; 
    12                                                   logic [6:0] HEX4; 
    13                                                   logic [6:0] HEX5;
    14                                                   logic [7:0] VGA_R; 
    15                                                   logic [7:0] VGA_G; 
    16                                                   logic [7:0] VGA_B;
    17                                                   logic VGA_HS; 
    18                                                   logic VGA_VS; 
    19                                                   logic VGA_CLK;
    20                                                   logic [7:0] VGA_X; 
    21                                                   logic [6:0] VGA_Y;
    22                                                   logic [2:0] VGA_COLOUR; 
    23                                                   logic VGA_PLOT;
    24                                               
    25                                               
    26                                                   task4 dut (.*);
    27              1                      42264         always #5 CLOCK_50 = ~CLOCK_50;  // Create clock with period=10
    27              2                      42263     
    28                                               
    29                                                   // Your testbench goes here. Our toplevel will give up after 1,000,000 ticks.
    30                                                   initial begin
    31              1                          1             KEY[3] = 0;
    32              1                          1             KEY[0] = 1;
    33              1                          1             #10;
    34              1                          1             KEY[3] = 1;
    35              1                          1             KEY[0] = 0;
    36                                               
    37                                                       //Done signal for reuleaux
    38              1                          1             wait(LEDR[0] == 1);
    39                                                       //Finished
    40              1                          1             $stop;
    41                                               
    42                                                   end
    43                                               endmodule: tb_task4
    44                                               // C:/Users/amran/OneDrive\ -\ UBC/Documents/UBC/School\ Work/2022W1/CPEN\ 311/2022w1-lab2-l1a-lab2-group1/vga-core/de1_vga_gui.tcl
    45                                               

Toggle Coverage:
    Enabled Coverage            Active      Hits    Misses % Covered
    ----------------            ------      ----    ------ ---------
    Toggle Bins                    206        43       163     20.87

================================Toggle Details================================

Toggle Coverage for File tb_task4.sv --

       Line                                   Node      1H->0L      0L->1H                          "Coverage"
--------------------------------------------------------------------------------------------------------------
          5                                 KEY[3]           0           1                               50.00 
          5                                 KEY[2]           0           0                                0.00 
          5                                 KEY[1]           0           0                                0.00 
          5                                 KEY[0]           1           0                               50.00 
          7                                LEDR[9]           0           0                                0.00 
          7                                LEDR[8]           0           0                                0.00 
          7                                LEDR[7]           0           0                                0.00 
          7                                LEDR[6]           0           0                                0.00 
          7                                LEDR[5]           0           0                                0.00 
          7                                LEDR[4]           0           0                                0.00 
          7                                LEDR[3]           0           0                                0.00 
          7                                LEDR[2]           0           0                                0.00 
          7                                LEDR[1]           0           0                                0.00 
          7                                LEDR[0]           0           0                                0.00 
          8                                HEX0[6]           0           0                                0.00 
          8                                HEX0[5]           0           0                                0.00 
          8                                HEX0[4]           0           0                                0.00 
          8                                HEX0[3]           0           0                                0.00 
          8                                HEX0[2]           0           0                                0.00 
          8                                HEX0[1]           0           0                                0.00 
          8                                HEX0[0]           0           0                                0.00 
          9                                HEX1[6]           0           0                                0.00 
          9                                HEX1[5]           0           0                                0.00 
          9                                HEX1[4]           0           0                                0.00 
          9                                HEX1[3]           0           0                                0.00 
          9                                HEX1[2]           0           0                                0.00 
          9                                HEX1[1]           0           0                                0.00 
          9                                HEX1[0]           0           0                                0.00 
         10                                HEX2[6]           0           0                                0.00 
         10                                HEX2[5]           0           0                                0.00 
         10                                HEX2[4]           0           0                                0.00 
         10                                HEX2[3]           0           0                                0.00 
         10                                HEX2[2]           0           0                                0.00 
         10                                HEX2[1]           0           0                                0.00 
         10                                HEX2[0]           0           0                                0.00 
         11                                HEX3[6]           0           0                                0.00 
         11                                HEX3[5]           0           0                                0.00 
         11                                HEX3[4]           0           0                                0.00 
         11                                HEX3[3]           0           0                                0.00 
         11                                HEX3[2]           0           0                                0.00 
         11                                HEX3[1]           0           0                                0.00 
         11                                HEX3[0]           0           0                                0.00 
         12                                HEX4[6]           0           0                                0.00 
         12                                HEX4[5]           0           0                                0.00 
         12                                HEX4[4]           0           0                                0.00 
         12                                HEX4[3]           0           0                                0.00 
         12                                HEX4[2]           0           0                                0.00 
         12                                HEX4[1]           0           0                                0.00 
         12                                HEX4[0]           0           0                                0.00 
         13                                HEX5[6]           0           0                                0.00 
         13                                HEX5[5]           0           0                                0.00 
         13                                HEX5[4]           0           0                                0.00 
         13                                HEX5[3]           0           0                                0.00 
         13                                HEX5[2]           0           0                                0.00 
         13                                HEX5[1]           0           0                                0.00 
         13                                HEX5[0]           0           0                                0.00 
         14                               VGA_R[7]           0           0                                0.00 
         14                               VGA_R[6]           0           0                                0.00 
         14                               VGA_R[5]           0           0                                0.00 
         14                               VGA_R[4]           0           0                                0.00 
         14                               VGA_R[3]           0           0                                0.00 
         14                               VGA_R[2]           0           0                                0.00 
         14                               VGA_R[1]           0           0                                0.00 
         14                               VGA_R[0]           0           0                                0.00 
         15                               VGA_G[7]           0           0                                0.00 
         15                               VGA_G[6]           0           0                                0.00 
         15                               VGA_G[5]           0           0                                0.00 
         15                               VGA_G[4]           0           0                                0.00 
         15                               VGA_G[3]           0           0                                0.00 
         15                               VGA_G[2]           0           0                                0.00 
         15                               VGA_G[1]           0           0                                0.00 
         15                               VGA_G[0]           0           0                                0.00 
         16                               VGA_B[7]           0           0                                0.00 
         16                               VGA_B[6]           0           0                                0.00 
         16                               VGA_B[5]           0           0                                0.00 
         16                               VGA_B[4]           0           0                                0.00 
         16                               VGA_B[3]           0           0                                0.00 
         16                               VGA_B[2]           0           0                                0.00 
         16                               VGA_B[1]           0           0                                0.00 
         16                               VGA_B[0]           0           0                                0.00 
         17                                 VGA_HS           0           0                                0.00 
         18                                 VGA_VS           0           0                                0.00 
         19                                VGA_CLK           1           0                               50.00 

Total Node Count     =        103 
Toggled Node Count   =         20 
Untoggled Node Count =         83 

Toggle Coverage      =      20.87% (43 of 206 bins)


Total Coverage By File (code coverage only, filtered view): 68.17%

